"use strict";(globalThis.webpackChunkcanvas_kit=globalThis.webpackChunkcanvas_kit||[]).push([[8849],{"./node_modules/react-innertext/index.js":module=>{var reduceJsxToString=function(previous,current){return previous+innerText(current)},innerText=function(jsx){return null===jsx||"boolean"==typeof jsx||void 0===jsx?"":"number"==typeof jsx?jsx.toString():"string"==typeof jsx?jsx:Array.isArray(jsx)?jsx.reduce(reduceJsxToString,""):function(jsx){return Object.prototype.hasOwnProperty.call(jsx,"props")}(jsx)&&Object.prototype.hasOwnProperty.call(jsx.props,"children")?innerText(jsx.props.children):""};innerText.default=innerText,module.exports=innerText},"./node_modules/@tanstack/react-virtual/dist/cjs/index.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const React=__webpack_require__("./node_modules/react/index.js"),reactDom=__webpack_require__("./node_modules/react-dom/index.js"),virtualCore=__webpack_require__("./node_modules/@tanstack/virtual-core/dist/cjs/index.cjs");function _interopNamespaceDefault(e){const n=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e)for(const k in e)if("default"!==k){const d=Object.getOwnPropertyDescriptor(e,k);Object.defineProperty(n,k,d.get?d:{enumerable:!0,get:()=>e[k]})}return n.default=e,Object.freeze(n)}const React__namespace=_interopNamespaceDefault(React),useIsomorphicLayoutEffect="undefined"!=typeof document?React__namespace.useLayoutEffect:React__namespace.useEffect;function useVirtualizerBase(options){const rerender=React__namespace.useReducer((()=>({})),{})[1],resolvedOptions={...options,onChange:(instance2,sync)=>{var _a;sync?reactDom.flushSync(rerender):rerender(),null==(_a=options.onChange)||_a.call(options,instance2,sync)}},[instance]=React__namespace.useState((()=>new virtualCore.Virtualizer(resolvedOptions)));return instance.setOptions(resolvedOptions),useIsomorphicLayoutEffect((()=>instance._didMount()),[]),useIsomorphicLayoutEffect((()=>instance._willUpdate())),instance}exports.useVirtualizer=function useVirtualizer(options){return useVirtualizerBase({observeElementRect:virtualCore.observeElementRect,observeElementOffset:virtualCore.observeElementOffset,scrollToFn:virtualCore.elementScroll,...options})},exports.useWindowVirtualizer=function useWindowVirtualizer(options){return useVirtualizerBase({getScrollElement:()=>"undefined"!=typeof document?window:null,observeElementRect:virtualCore.observeWindowRect,observeElementOffset:virtualCore.observeWindowOffset,scrollToFn:virtualCore.windowScroll,initialOffset:()=>"undefined"!=typeof document?window.scrollY:0,...options})},Object.keys(virtualCore).forEach((k=>{"default"===k||Object.prototype.hasOwnProperty.call(exports,k)||Object.defineProperty(exports,k,{enumerable:!0,get:()=>virtualCore[k]})}))},"./node_modules/@tanstack/virtual-core/dist/cjs/index.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const utils=__webpack_require__("./node_modules/@tanstack/virtual-core/dist/cjs/utils.cjs"),getRect=element=>{const{offsetWidth,offsetHeight}=element;return{width:offsetWidth,height:offsetHeight}},defaultKeyExtractor=index=>index,defaultRangeExtractor=range=>{const start=Math.max(range.startIndex-range.overscan,0),end=Math.min(range.endIndex+range.overscan,range.count-1),arr=[];for(let i=start;i<=end;i++)arr.push(i);return arr},addEventListenerOptions={passive:!0},supportsScrollend="undefined"==typeof window||"onscrollend"in window,measureElement=(element,entry,instance)=>{if(null==entry?void 0:entry.borderBoxSize){const box=entry.borderBoxSize[0];if(box){return Math.round(box[instance.options.horizontal?"inlineSize":"blockSize"])}}return element[instance.options.horizontal?"offsetWidth":"offsetHeight"]};const findNearestBinarySearch=(low,high,getCurrentValue,value)=>{for(;low<=high;){const middle=(low+high)/2|0,currentValue=getCurrentValue(middle);if(currentValue<value)low=middle+1;else{if(!(currentValue>value))return middle;high=middle-1}}return low>0?low-1:0};exports.approxEqual=utils.approxEqual,exports.debounce=utils.debounce,exports.memo=utils.memo,exports.notUndefined=utils.notUndefined,exports.Virtualizer=class Virtualizer{constructor(opts){this.unsubs=[],this.scrollElement=null,this.targetWindow=null,this.isScrolling=!1,this.scrollToIndexTimeoutId=null,this.measurementsCache=[],this.itemSizeCache=new Map,this.pendingMeasuredCacheIndexes=[],this.scrollRect=null,this.scrollOffset=null,this.scrollDirection=null,this.scrollAdjustments=0,this.elementsCache=new Map,this.observer=(()=>{let _ro=null;const get=()=>_ro||(this.targetWindow&&this.targetWindow.ResizeObserver?_ro=new this.targetWindow.ResizeObserver((entries=>{entries.forEach((entry=>{const run=()=>{this._measureElement(entry.target,entry)};this.options.useAnimationFrameWithResizeObserver?requestAnimationFrame(run):run()}))})):null);return{disconnect:()=>{var _a;null==(_a=get())||_a.disconnect(),_ro=null},observe:target=>{var _a;return null==(_a=get())?void 0:_a.observe(target,{box:"border-box"})},unobserve:target=>{var _a;return null==(_a=get())?void 0:_a.unobserve(target)}}})(),this.range=null,this.setOptions=opts2=>{Object.entries(opts2).forEach((([key,value])=>{void 0===value&&delete opts2[key]})),this.options={debug:!1,initialOffset:0,overscan:1,paddingStart:0,paddingEnd:0,scrollPaddingStart:0,scrollPaddingEnd:0,horizontal:!1,getItemKey:defaultKeyExtractor,rangeExtractor:defaultRangeExtractor,onChange:()=>{},measureElement,initialRect:{width:0,height:0},scrollMargin:0,gap:0,indexAttribute:"data-index",initialMeasurementsCache:[],lanes:1,isScrollingResetDelay:150,enabled:!0,isRtl:!1,useScrollendEvent:!1,useAnimationFrameWithResizeObserver:!1,...opts2}},this.notify=sync=>{var _a,_b;null==(_b=(_a=this.options).onChange)||_b.call(_a,this,sync)},this.maybeNotify=utils.memo((()=>(this.calculateRange(),[this.isScrolling,this.range?this.range.startIndex:null,this.range?this.range.endIndex:null])),(isScrolling=>{this.notify(isScrolling)}),{key:!1,debug:()=>this.options.debug,initialDeps:[this.isScrolling,this.range?this.range.startIndex:null,this.range?this.range.endIndex:null]}),this.cleanup=()=>{this.unsubs.filter(Boolean).forEach((d=>d())),this.unsubs=[],this.observer.disconnect(),this.scrollElement=null,this.targetWindow=null},this._didMount=()=>()=>{this.cleanup()},this._willUpdate=()=>{var _a;const scrollElement=this.options.enabled?this.options.getScrollElement():null;if(this.scrollElement!==scrollElement){if(this.cleanup(),!scrollElement)return void this.maybeNotify();this.scrollElement=scrollElement,this.scrollElement&&"ownerDocument"in this.scrollElement?this.targetWindow=this.scrollElement.ownerDocument.defaultView:this.targetWindow=(null==(_a=this.scrollElement)?void 0:_a.window)??null,this.elementsCache.forEach((cached=>{this.observer.observe(cached)})),this._scrollToOffset(this.getScrollOffset(),{adjustments:void 0,behavior:void 0}),this.unsubs.push(this.options.observeElementRect(this,(rect=>{this.scrollRect=rect,this.maybeNotify()}))),this.unsubs.push(this.options.observeElementOffset(this,((offset,isScrolling)=>{this.scrollAdjustments=0,this.scrollDirection=isScrolling?this.getScrollOffset()<offset?"forward":"backward":null,this.scrollOffset=offset,this.isScrolling=isScrolling,this.maybeNotify()})))}},this.getSize=()=>this.options.enabled?(this.scrollRect=this.scrollRect??this.options.initialRect,this.scrollRect[this.options.horizontal?"width":"height"]):(this.scrollRect=null,0),this.getScrollOffset=()=>this.options.enabled?(this.scrollOffset=this.scrollOffset??("function"==typeof this.options.initialOffset?this.options.initialOffset():this.options.initialOffset),this.scrollOffset):(this.scrollOffset=null,0),this.getFurthestMeasurement=(measurements,index)=>{const furthestMeasurementsFound=new Map,furthestMeasurements=new Map;for(let m=index-1;m>=0;m--){const measurement=measurements[m];if(furthestMeasurementsFound.has(measurement.lane))continue;const previousFurthestMeasurement=furthestMeasurements.get(measurement.lane);if(null==previousFurthestMeasurement||measurement.end>previousFurthestMeasurement.end?furthestMeasurements.set(measurement.lane,measurement):measurement.end<previousFurthestMeasurement.end&&furthestMeasurementsFound.set(measurement.lane,!0),furthestMeasurementsFound.size===this.options.lanes)break}return furthestMeasurements.size===this.options.lanes?Array.from(furthestMeasurements.values()).sort(((a,b)=>a.end===b.end?a.index-b.index:a.end-b.end))[0]:void 0},this.getMeasurementOptions=utils.memo((()=>[this.options.count,this.options.paddingStart,this.options.scrollMargin,this.options.getItemKey,this.options.enabled]),((count,paddingStart,scrollMargin,getItemKey,enabled)=>(this.pendingMeasuredCacheIndexes=[],{count,paddingStart,scrollMargin,getItemKey,enabled})),{key:!1}),this.getMeasurements=utils.memo((()=>[this.getMeasurementOptions(),this.itemSizeCache]),(({count,paddingStart,scrollMargin,getItemKey,enabled},itemSizeCache)=>{if(!enabled)return this.measurementsCache=[],this.itemSizeCache.clear(),[];0===this.measurementsCache.length&&(this.measurementsCache=this.options.initialMeasurementsCache,this.measurementsCache.forEach((item=>{this.itemSizeCache.set(item.key,item.size)})));const min=this.pendingMeasuredCacheIndexes.length>0?Math.min(...this.pendingMeasuredCacheIndexes):0;this.pendingMeasuredCacheIndexes=[];const measurements=this.measurementsCache.slice(0,min);for(let i=min;i<count;i++){const key=getItemKey(i),furthestMeasurement=1===this.options.lanes?measurements[i-1]:this.getFurthestMeasurement(measurements,i),start=furthestMeasurement?furthestMeasurement.end+this.options.gap:paddingStart+scrollMargin,measuredSize=itemSizeCache.get(key),size="number"==typeof measuredSize?measuredSize:this.options.estimateSize(i),end=start+size,lane=furthestMeasurement?furthestMeasurement.lane:i%this.options.lanes;measurements[i]={index:i,start,size,end,key,lane}}return this.measurementsCache=measurements,measurements}),{key:!1,debug:()=>this.options.debug}),this.calculateRange=utils.memo((()=>[this.getMeasurements(),this.getSize(),this.getScrollOffset(),this.options.lanes]),((measurements,outerSize,scrollOffset,lanes)=>this.range=measurements.length>0&&outerSize>0?function calculateRange({measurements,outerSize,scrollOffset,lanes}){const lastIndex=measurements.length-1,getOffset=index=>measurements[index].start;if(measurements.length<=lanes)return{startIndex:0,endIndex:lastIndex};let startIndex=findNearestBinarySearch(0,lastIndex,getOffset,scrollOffset),endIndex=startIndex;if(1===lanes)for(;endIndex<lastIndex&&measurements[endIndex].end<scrollOffset+outerSize;)endIndex++;else if(lanes>1){const endPerLane=Array(lanes).fill(0);for(;endIndex<lastIndex&&endPerLane.some((pos=>pos<scrollOffset+outerSize));){const item=measurements[endIndex];endPerLane[item.lane]=item.end,endIndex++}const startPerLane=Array(lanes).fill(scrollOffset+outerSize);for(;startIndex>=0&&startPerLane.some((pos=>pos>=scrollOffset));){const item=measurements[startIndex];startPerLane[item.lane]=item.start,startIndex--}startIndex=Math.max(0,startIndex-startIndex%lanes),endIndex=Math.min(lastIndex,endIndex+(lanes-1-endIndex%lanes))}return{startIndex,endIndex}}({measurements,outerSize,scrollOffset,lanes}):null),{key:!1,debug:()=>this.options.debug}),this.getVirtualIndexes=utils.memo((()=>{let startIndex=null,endIndex=null;const range=this.calculateRange();return range&&(startIndex=range.startIndex,endIndex=range.endIndex),this.maybeNotify.updateDeps([this.isScrolling,startIndex,endIndex]),[this.options.rangeExtractor,this.options.overscan,this.options.count,startIndex,endIndex]}),((rangeExtractor,overscan,count,startIndex,endIndex)=>null===startIndex||null===endIndex?[]:rangeExtractor({startIndex,endIndex,overscan,count})),{key:!1,debug:()=>this.options.debug}),this.indexFromElement=node=>{const attributeName=this.options.indexAttribute,indexStr=node.getAttribute(attributeName);return indexStr?parseInt(indexStr,10):(console.warn(`Missing attribute name '${attributeName}={index}' on measured element.`),-1)},this._measureElement=(node,entry)=>{const index=this.indexFromElement(node),item=this.measurementsCache[index];if(!item)return;const key=item.key,prevNode=this.elementsCache.get(key);prevNode!==node&&(prevNode&&this.observer.unobserve(prevNode),this.observer.observe(node),this.elementsCache.set(key,node)),node.isConnected&&this.resizeItem(index,this.options.measureElement(node,entry,this))},this.resizeItem=(index,size)=>{const item=this.measurementsCache[index];if(!item)return;const delta=size-(this.itemSizeCache.get(item.key)??item.size);0!==delta&&((void 0!==this.shouldAdjustScrollPositionOnItemSizeChange?this.shouldAdjustScrollPositionOnItemSizeChange(item,delta,this):item.start<this.getScrollOffset()+this.scrollAdjustments)&&this._scrollToOffset(this.getScrollOffset(),{adjustments:this.scrollAdjustments+=delta,behavior:void 0}),this.pendingMeasuredCacheIndexes.push(item.index),this.itemSizeCache=new Map(this.itemSizeCache.set(item.key,size)),this.notify(!1))},this.measureElement=node=>{node?this._measureElement(node,void 0):this.elementsCache.forEach(((cached,key)=>{cached.isConnected||(this.observer.unobserve(cached),this.elementsCache.delete(key))}))},this.getVirtualItems=utils.memo((()=>[this.getVirtualIndexes(),this.getMeasurements()]),((indexes,measurements)=>{const virtualItems=[];for(let k=0,len=indexes.length;k<len;k++){const measurement=measurements[indexes[k]];virtualItems.push(measurement)}return virtualItems}),{key:!1,debug:()=>this.options.debug}),this.getVirtualItemForOffset=offset=>{const measurements=this.getMeasurements();if(0!==measurements.length)return utils.notUndefined(measurements[findNearestBinarySearch(0,measurements.length-1,(index=>utils.notUndefined(measurements[index]).start),offset)])},this.getOffsetForAlignment=(toOffset,align,itemSize=0)=>{const size=this.getSize(),scrollOffset=this.getScrollOffset();"auto"===align&&(align=toOffset>=scrollOffset+size?"end":"start"),"center"===align?toOffset+=(itemSize-size)/2:"end"===align&&(toOffset-=size);const maxOffset=this.getTotalSize()-size;return Math.max(Math.min(maxOffset,toOffset),0)},this.getOffsetForIndex=(index,align="auto")=>{index=Math.max(0,Math.min(index,this.options.count-1));const item=this.measurementsCache[index];if(!item)return;const size=this.getSize(),scrollOffset=this.getScrollOffset();if("auto"===align)if(item.end>=scrollOffset+size-this.options.scrollPaddingEnd)align="end";else{if(!(item.start<=scrollOffset+this.options.scrollPaddingStart))return[scrollOffset,align];align="start"}const toOffset="end"===align?item.end+this.options.scrollPaddingEnd:item.start-this.options.scrollPaddingStart;return[this.getOffsetForAlignment(toOffset,align,item.size),align]},this.isDynamicMode=()=>this.elementsCache.size>0,this.cancelScrollToIndex=()=>{null!==this.scrollToIndexTimeoutId&&this.targetWindow&&(this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId),this.scrollToIndexTimeoutId=null)},this.scrollToOffset=(toOffset,{align="start",behavior}={})=>{this.cancelScrollToIndex(),"smooth"===behavior&&this.isDynamicMode()&&console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."),this._scrollToOffset(this.getOffsetForAlignment(toOffset,align),{adjustments:void 0,behavior})},this.scrollToIndex=(index,{align:initialAlign="auto",behavior}={})=>{index=Math.max(0,Math.min(index,this.options.count-1)),this.cancelScrollToIndex(),"smooth"===behavior&&this.isDynamicMode()&&console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");const offsetAndAlign=this.getOffsetForIndex(index,initialAlign);if(!offsetAndAlign)return;const[offset,align]=offsetAndAlign;this._scrollToOffset(offset,{adjustments:void 0,behavior}),"smooth"!==behavior&&this.isDynamicMode()&&this.targetWindow&&(this.scrollToIndexTimeoutId=this.targetWindow.setTimeout((()=>{this.scrollToIndexTimeoutId=null;if(this.elementsCache.has(this.options.getItemKey(index))){const result=this.getOffsetForIndex(index,align);if(!result)return;const[latestOffset]=result,currentScrollOffset=this.getScrollOffset();utils.approxEqual(latestOffset,currentScrollOffset)||this.scrollToIndex(index,{align,behavior})}else this.scrollToIndex(index,{align,behavior})})))},this.scrollBy=(delta,{behavior}={})=>{this.cancelScrollToIndex(),"smooth"===behavior&&this.isDynamicMode()&&console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."),this._scrollToOffset(this.getScrollOffset()+delta,{adjustments:void 0,behavior})},this.getTotalSize=()=>{var _a;const measurements=this.getMeasurements();let end;if(0===measurements.length)end=this.options.paddingStart;else if(1===this.options.lanes)end=(null==(_a=measurements[measurements.length-1])?void 0:_a.end)??0;else{const endByLane=Array(this.options.lanes).fill(null);let endIndex=measurements.length-1;for(;endIndex>=0&&endByLane.some((val=>null===val));){const item=measurements[endIndex];null===endByLane[item.lane]&&(endByLane[item.lane]=item.end),endIndex--}end=Math.max(...endByLane.filter((val=>null!==val)))}return Math.max(end-this.options.scrollMargin+this.options.paddingEnd,0)},this._scrollToOffset=(offset,{adjustments,behavior})=>{this.options.scrollToFn(offset,{behavior,adjustments},this)},this.measure=()=>{this.itemSizeCache=new Map,this.notify(!1)},this.setOptions(opts)}},exports.defaultKeyExtractor=defaultKeyExtractor,exports.defaultRangeExtractor=defaultRangeExtractor,exports.elementScroll=(offset,{adjustments=0,behavior},instance)=>{var _a,_b;const toOffset=offset+adjustments;null==(_b=null==(_a=instance.scrollElement)?void 0:_a.scrollTo)||_b.call(_a,{[instance.options.horizontal?"left":"top"]:toOffset,behavior})},exports.measureElement=measureElement,exports.observeElementOffset=(instance,cb)=>{const element=instance.scrollElement;if(!element)return;const targetWindow=instance.targetWindow;if(!targetWindow)return;let offset=0;const fallback=instance.options.useScrollendEvent&&supportsScrollend?()=>{}:utils.debounce(targetWindow,(()=>{cb(offset,!1)}),instance.options.isScrollingResetDelay),createHandler=isScrolling=>()=>{const{horizontal,isRtl}=instance.options;offset=horizontal?element.scrollLeft*(isRtl?-1:1):element.scrollTop,fallback(),cb(offset,isScrolling)},handler=createHandler(!0),endHandler=createHandler(!1);endHandler(),element.addEventListener("scroll",handler,addEventListenerOptions);const registerScrollendEvent=instance.options.useScrollendEvent&&supportsScrollend;return registerScrollendEvent&&element.addEventListener("scrollend",endHandler,addEventListenerOptions),()=>{element.removeEventListener("scroll",handler),registerScrollendEvent&&element.removeEventListener("scrollend",endHandler)}},exports.observeElementRect=(instance,cb)=>{const element=instance.scrollElement;if(!element)return;const targetWindow=instance.targetWindow;if(!targetWindow)return;const handler=rect=>{const{width,height}=rect;cb({width:Math.round(width),height:Math.round(height)})};if(handler(getRect(element)),!targetWindow.ResizeObserver)return()=>{};const observer=new targetWindow.ResizeObserver((entries=>{const run=()=>{const entry=entries[0];if(null==entry?void 0:entry.borderBoxSize){const box=entry.borderBoxSize[0];if(box)return void handler({width:box.inlineSize,height:box.blockSize})}handler(getRect(element))};instance.options.useAnimationFrameWithResizeObserver?requestAnimationFrame(run):run()}));return observer.observe(element,{box:"border-box"}),()=>{observer.unobserve(element)}},exports.observeWindowOffset=(instance,cb)=>{const element=instance.scrollElement;if(!element)return;const targetWindow=instance.targetWindow;if(!targetWindow)return;let offset=0;const fallback=instance.options.useScrollendEvent&&supportsScrollend?()=>{}:utils.debounce(targetWindow,(()=>{cb(offset,!1)}),instance.options.isScrollingResetDelay),createHandler=isScrolling=>()=>{offset=element[instance.options.horizontal?"scrollX":"scrollY"],fallback(),cb(offset,isScrolling)},handler=createHandler(!0),endHandler=createHandler(!1);endHandler(),element.addEventListener("scroll",handler,addEventListenerOptions);const registerScrollendEvent=instance.options.useScrollendEvent&&supportsScrollend;return registerScrollendEvent&&element.addEventListener("scrollend",endHandler,addEventListenerOptions),()=>{element.removeEventListener("scroll",handler),registerScrollendEvent&&element.removeEventListener("scrollend",endHandler)}},exports.observeWindowRect=(instance,cb)=>{const element=instance.scrollElement;if(!element)return;const handler=()=>{cb({width:element.innerWidth,height:element.innerHeight})};return handler(),element.addEventListener("resize",handler,addEventListenerOptions),()=>{element.removeEventListener("resize",handler)}},exports.windowScroll=(offset,{adjustments=0,behavior},instance)=>{var _a,_b;const toOffset=offset+adjustments;null==(_b=null==(_a=instance.scrollElement)?void 0:_a.scrollTo)||_b.call(_a,{[instance.options.horizontal?"left":"top"]:toOffset,behavior})}},"./node_modules/@tanstack/virtual-core/dist/cjs/utils.cjs":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});exports.approxEqual=(a,b)=>Math.abs(a-b)<=1,exports.debounce=(targetWindow,fn,ms)=>{let timeoutId;return function(...args){targetWindow.clearTimeout(timeoutId),timeoutId=targetWindow.setTimeout((()=>fn.apply(this,args)),ms)}},exports.memo=function memo(getDeps,fn,opts){let result,deps=opts.initialDeps??[];function memoizedFunction(){var _a,_b,_c,_d;let depTime;opts.key&&(null==(_a=opts.debug)?void 0:_a.call(opts))&&(depTime=Date.now());const newDeps=getDeps();if(!(newDeps.length!==deps.length||newDeps.some(((dep,index)=>deps[index]!==dep))))return result;let resultTime;if(deps=newDeps,opts.key&&(null==(_b=opts.debug)?void 0:_b.call(opts))&&(resultTime=Date.now()),result=fn(...newDeps),opts.key&&(null==(_c=opts.debug)?void 0:_c.call(opts))){const depEndTime=Math.round(100*(Date.now()-depTime))/100,resultEndTime=Math.round(100*(Date.now()-resultTime))/100,resultFpsPercentage=resultEndTime/16,pad=(str,num)=>{for(str=String(str);str.length<num;)str=" "+str;return str};console.info(`%c⏱ ${pad(resultEndTime,5)} /${pad(depEndTime,5)} ms`,`\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0,Math.min(120-120*resultFpsPercentage,120))}deg 100% 31%);`,null==opts?void 0:opts.key)}return null==(_d=null==opts?void 0:opts.onChange)||_d.call(opts,result),result}return memoizedFunction.updateDeps=newDeps=>{deps=newDeps},memoizedFunction},exports.notUndefined=function notUndefined(value,msg){if(void 0===value)throw new Error("Unexpected undefined"+(msg?`: ${msg}`:""));return value}}}]);