import {ExampleCodeBlock, SymbolDoc} from '@workday/canvas-kit-docs';
import {StylingOverrides} from './examples/StylingOverrides';

<Meta title="Styling/Data Part" />

## Styling Elements via Data Part

The goal of compound components is to expose one component per semantic element. Most of the time
this means a 1:1 relationship of a component and DOM element. Sometimes a semantic element contains
non-semantic elements for styling. An example might be a `<button>` with a icon for visual
reinforcement, and a label for a semantic label. The semantic element is the `<button>` while the
icon has no semantic value and the label automatically provides the semantic button with an
accessible name. In order to style the icon and label elements, you have to know the DOM structure
to target those specific elements in order to style it.

```tsx
import {createStencil} from '@workday/canvas-kit-styling';

const myButtonStencil = createStencil({
  base: {
    background: 'transparent',
    i: {
      // ...icon styles
    },
    span: {
      // ...label styles
    },
    ':hover': {
      // ...hover button styles
      i: {
        // ...hover icon styles
      },
      span: {
        // ...hover label styles
      },
    },
  },
});
const MyButton = ({children, ...elemProps}) => {
  return (
    <button {...handleCsProp(elemProps, myButtonStencil())}>
      <i />
      <span>{children}</span>
    </button>
  );
};
```

## Using `data-part` to Style Elements

In order to style elements that are not exposed in the API, we can use the `data-part` attribute.
This allows us to target specific elements in the component without having to know the DOM
structure. In the example below, we can use the `data-part` attribute to style the icon and label
element.

```tsx
import {createStencil, handleCsProp} from '@workday/canvas-kit-styling';

const myButtonStencil = createStencil({
  parts: {
	  icon: 'my-button-icon',
		label: 'my-button-label'
  },
  base: ({iconPart, labelPart}) => ({
		background: 'transparent',
		[iconPart]: { // `[data-part="my-button-icon"]`
		  // ...icon styles
		},
		[labelPart]: { // `[data-part="my-button-label"]`
			// ...label styles
		},
		'&:hover': {
			// ...hover styles for button element
			[iconPart]: {
				// ...hover styles for icon part
			}
		}
  });
});
const MyButton = ({children, ...elemProps}) => {
  return (
		<button {...handleCsProp(elemProps, myButtonStencil()) }>
      <i data-part={myButtonStencil.parts.icon} />
      <span data-part={myButtonStencil.parts.label}>{children}</span>
		</button>
  );
};
```

As a reusable component, you can use the `data-part` attribute to style elements that are not
exposed in the API. Consumers can also use the type safe stencil to target that element to style it
as well. As a general rule, a Stencil maps to a component. Multiple Stencils per component usually
means nested elements that are not targets for style overrides.

> **Note:** While the `data-part` is a way to give access to elements in order to style, it should
> be used sparingly. Using `data-part` increases CSS specificity. A `data-part` should not be used
> on a nested component that has its own Stencil. The result will be any style properties defined in
> a `data-part` block will have a higher specificity than other styles.
