import {Meta} from '@storybook/addon-docs/blocks';

<Meta title="Welcome/Migration Guides/v5.0" />

# Canvas Kit 5.0 Migration Guide

Below are the breaking changes made in Canvas Kit v5. Please
[reach out](https://github.com/Workday/canvas-kit/issues/new?labels=bug&template=bug.md) if you have
any questions about the update.

- [Codemod](#codemod)
- [General Changes](#general-changes)
  - [Slash Imports](#slash-imports)
  - [Canvas Kit Preview](#canvas-kit-preview)
  - [Canvas Kit CSS Maintenance Mode](#canvas-kit-css-maintenance-mode)
- [Component Changes](#component-changes)
  - [Component Promotions](#component-promotions)
  - [Core](#core)
  - [Tokens](#tokens)
  - [Button](#button)
  - [Card](#card)
  - [Inputs](#inputs)
  - [Tabs](#tabs)
  - [Popper](#popper)
  - [Popups](#popups)
  - [Skeleton](#skeleton)

## Codemod

We've introduced a [new codemod package](./modules/codemod) you can use to automatically update your
code to work with a majority of the breaking changes in the migration from Canvas Kit v4 to v5.
Simply run:

```sh
> npx @workday/canvas-kit-codemod v5 [path]
```

> Note: This codemod only works on `.js`, `.jsx`, `.ts`, and `.tsx` extensions. You may need to make
> some manual changes in other file types (`.json`, `.mdx`, `.md`, etc.).

> Note: You may need to run your linter after executing the codemod, as it's resulting formatting
> (spacing, quotes, etc.) may not match your project's styling.

**Breaking changes accounted for by this codemod will be marked with a 🤖.**

Please verify all changes made by the codemod, and
[let us know](https://github.com/Workday/canvas-kit/issues/new?labels=bug&template=bug.md) if you
encounter any issues or use cases that we've missed. The `@workday/canvas-kit-codemod` package will
help us maintain additional codemod transforms to make future migrations easier.

## General Changes

### Slash Imports

Rather than having a separate module for each component, we've moved to a slash imports system. All
of our React components are now bundled in one of three modules:

- `@workday/canvas-kit-react`
- `@workday/canvas-kit-labs-react`
- `@workday/canvas-kit-preview-react`

> Note: See [Canvas Kit Preview](#canvas-kit-preview) for more information about the new
> `@workday/canvas-kit-preview-react` module.

Consequently, you'll need to update your import statements:

```tsx
// v4
import {TextInput} from '@workday/canvas-kit-react-text-input';

// v5
import {TextInput} from '@workday/canvas-kit-react/text-input';
```

🤖 The codemod will update import statements to use the new slash imports syntax.

Recall that the codemod only works on `.js`, `.jsx`, `.ts`, and `.tsx` extensions. Other file types
will need to be updated manually.

### Canvas Kit Preview

Due to the broad range of stability in [Canvas Kit Labs](../../labs-react)
(`@workday/canvas-kit-labs-react`), we've introduced a new module called
[Canvas Kit Preview](../../preview-react) (`@workday/canvas-kit-preview-react`) to provide consumers
with more clarity and confidence when uptaking experimental and upcoming components. The components
in Preview have had a full design and accessibility review and are approved for use in product.
Their functionality and design are set, but their APIs and/or underlying architecture are still
subject to change.

Preview serves as a staging ground for components that are ready to use, but may not be up to the
high code standards upheld in the Main `@workday/canvas-kit-react` module. Think of Labs as a space
for alpha components and Preview as a space for beta components.

We've promoted several components from Labs to Preview in v5. See
[Component Promotions](#component-promotions) for more details.

### Canvas Kit CSS Maintenance Mode

Due to the infrequent use of our CSS modules, we've placed them in maintenance mode in v5. Although
we'll continue to support `@workday/canvas-kit-css` with bug fixes and significant visual updates,
it most likely won't be receiving new components or additional features. This will allow us to
provide more focused support and to dedicate our efforts to making bigger and better improvements to
our most used components: Canvas Kit React. If you have questions or concerns, please
[let us know](https://github.com/Workday/canvas-kit/issues/new?labels=&template=question.md).

## Component Changes

### Component Promotions

#### Promotions from Labs to Preview

The following components were promoted from Labs to the new Preview module:

- Breadcrumbs
- Color Picker
- Core `type` > Tokens `type`
- Menu
- Select
- Side Panel

You'll need to update your imports for promoted components (this is _not_ handled by the codemod):

```tsx
// v4
import {Breadcrumbs} from '@workday/canvas-kit-labs-react-breadcrumbs';

// v5
import {Breadcrumbs} from '@workday/canvas-kit-preview-react/breadcrumbs';
```

#### Promotions from Labs to Main

Generally, a component will begin in Labs before it's promoted to Preview and eventually to Main
(although there is no guarantee a component will advance out of Labs). Given that Preview was just
introduced in v5, however, we believe that a few components have incubated long enough in Labs and
are ready for Main. The following components have been promoted straight from Labs to Main:

- Pagination
- Tabs

These imports will need to be updated manually as well (this is _not_ handled by the codemod):

```tsx
// v4
import {Pagination} from '@workday/canvas-kit-labs-react-pagination';

// v5
import {Pagination} from '@workday/canvas-kit-react/pagination';
```

### Core

#### Rename Core to Tokens

The distinction between our core and common packages is often unclear and creates confusion around
what should be imported from where. To help alleviate this and better align with our design
taxonomy, we've renamed our `core` modules in both Main and Labs to `tokens`. We've also removed the
`type` default export in the Labs core package in favor of named imports. These changes are listed
below, all of which are handled by the v5 codemod.

##### Automatic Updates

- 🤖 Rename Main `core` import statements to `tokens`

  ```tsx
  // v4
  import {colors} from '@workday/canvas-kit-react-core';

  // v5
  import {colors} from '@workday/canvas-kit-react/tokens';
  ```

- 🤖 Rename Labs `core` import statements to `tokens`

  ```tsx
  // v4
  import {type} from '@workday/canvas-kit-labs-react-core';

  // v5
  import {type} from '@workday/canvas-kit-labs-react/tokens';
  ```

- 🤖 Replace default `type` import in Labs `core` with named import

  ```tsx
  // v4
  import type from '@workday/canvas-kit-labs-react-core';

  // v5
  import {type} from '@workday/canvas-kit-labs-react/tokens';
  ```

#### Input Provider

The `InputProvider` wrapper component (used to provide CSS-referencable data attributes for the
user's current input method) has been moved from `@workday/canvas-kit-react-core` to
`@workday/canvas-kit-react/common`. After renaming our `core` package to `tokens`, it no longer made
sense in this location.

```tsx
// v4
import {InputProvider} from '@workday/canvas-kit-react-core';

// v5
import {InputProvider} from '@workday/canvas-kit-react/common';
```

🤖 The codemod will update your `InputProvider` imports.

#### Space Style Function

The `space` style function in Labs `core` (now Labs `tokens`) has been removed. Please use `Box`
instead. For example:

```tsx
// v4
import {spaceNumbers} from '@workday/canvas-kit-react-core';
import {space} from '@workday/canvas-kit-labs-react-core';
// A styled div with space props
const Box = styled('div')(space);

<Box p={spaceNumbers.xl}>Ye Olde SpaceBox</Box>;

// v5
import {Box} from '@workday/canvas-kit-labs-react/common';

// You can also use `padding={spaceNumbers.xl}` or `padding={space.xl}`
<Box padding="xl">New Box</Box>;
```

### Tokens

#### Space

To better align with our design taxonomy, we've renamed our space tokens in our `tokens` package
(formerly in `core`). Instead of relying on `@workday/canvas-space-web` to supply our space values,
we're now keeping those values in canvas-kit. We've also taken the opportunity to improve the space
types (which were too generic) and their JSDoc hints.

The following table describes each update:

| Before                | After                     | Change Description               |
| --------------------- | ------------------------- | -------------------------------- |
| `spacing`             | `space`                   | name change only                 |
| `spacingNumbers`      | `spaceNumbers`            | name change only                 |
| `CanvasSpacing`       | `CanvasSpace`             | name change and improved types\* |
| `CanvasSpacingValue`  | `CanvasSpaceValues`       | name change only                 |
| `CanvasSpacingNumber` | `CanvasSpaceNumbers`      | name change and improved types\* |
| `n/a`                 | `CanvasSpaceNumberValues` | new type!                        |

\* Before, the types were too generic and not very useful. They now better reflect the values they
represent.

The codemod will handle _almost all_ of these changes with a few possible exceptions noted in
[Manual Updates](#manual-updates) below.

##### Automatic Updates

- 🤖 Rename `spacing` and `spacingNumbers` imports.

  ```tsx
  // v4
  import {spacing, spacingNumbers} from '@workday/canvas-kit-react-core';

  // v5
  import {space, spaceNumbers} from '@workday/canvas-kit-react/tokens';
  ```

- 🤖 Rename `CanvasSpacing`, `CanvasSpacingValue`, and `CanvasSpacingNumber` imports.

  ```tsx
  // v4
  import {
    CanvasSpacing,
    CanvasSpacingValue,
    CanvasSpacingNumber,
  } from '@workday/canvas-kit-react-core';

  // v5
  import {
    CanvasSpace,
    CanvasSpaceValues,
    CanvasSpaceNumbers,
  } from '@workday/canvas-kit-react/tokens';
  ```

- 🤖 Update token expressions.

  ```tsx
  // v4
  const iconPadding = spacing.s;

  // v5
  const iconPadding = space.s;
  ```

- 🤖 Update type expressions.

  ```tsx
  // v4
  const getSpace = (value: CanvasSpacingValue) => spacing[value];

  // v5
  const getSpace = (value: CanvasSpaceValue) => space[value];
  ```

- 🤖 Update token properties.

  ```tsx
  // v4
  const iconPadding = canvas.spacing.s;

  // v5
  const iconPadding = canvas.space.s;
  ```

##### Manual Updates

As previously mentioned, the codemod should handle the vast majority of these updates. However,
there are potentially a few changes that will need to be made manually. There may be more beyond
what's listed below, but these were the most common issues found in our investigation.

- Usage outside of `.js`, `.jsx`, `.ts`, and `.tsx` files
  - e.g. referencing `spacing` in documentation (`.md` files)
- Usage in code comments or JSDoc comments
  - e.g. `// spacing.s = 16px`
- Re-declararation `space` or `spaceNumbers` in the same files
  - e.g. importing or declaring a new `space` or `spaceNumbers` variable will prevent the codemod
    from updating the file
- Aliasing existing variables as `spacing` or `spaceNumbers`
  - e.g. `import {spacingNumbers as spacing}` will prevent the codemod from updating the file

#### Border Radius

We've updated the border radius `zero` token value from `0` to `"0px"` for consistency given that
all other border radius tokens use string pixel values. We highly doubt this change will cause any
issues, but because the value's type is different, this is technically a breaking change.

```tsx
// v4
import {borderRadius} from '@workday/canvas-kit-react-core';

console.log(borderRadius.zero); // returns `0`

// v5
import {borderRadius} from '@workday/canvas-kit-react/tokens';

console.log(borderRadius.zero); // returns "0px"
```

### Button

#### Recategorization

There has been common confusion around the large number of buttons Canvas supports and when each
should be used. To improve the usability of our design system, we've been working to recategorize
and simplify our button offering. To align with the recent changes in our Figma libraries, we've
reorganized our buttons, renaming a few and removing others.

The majority of button use cases have been simplified into three different components:
`PrimaryButton`, `SecondaryButton`, and `TertiaryButton`, each level representing its emphasis and
hierarchy in a UI. We hope this makes your usage of our buttons more intentional and clear. We've
provided a codemod to make these changes automatically.

**Renamed:**

- 🤖 `Button` has been split into `PrimaryButton` and `SecondaryButton` (depending on the `variant`
  prop).
- 🤖 `OutlineButton` (`secondary`) is now `SecondaryButton`. For accessibility reasons, the
  "outline" styling is the new styling for our secondary buttons.
- 🤖 `OutlineButton` (`inverse`) is now `SecondaryButton` with an `inverse` variant.
- 🤖 `TextButton` is now `TertiaryButton`.

**Removed:**

- 🤖 `HighlightButton`. Use `SecondaryButton` instead.
- 🤖 `OutlineButton` with `primary` variant. Use `PrimaryButton` or `SecondaryButton` instead. The
  codemod will replace with `SecondaryButton`.
- 🤖 `DropdownButton`. This can be achieved simply using `PrimaryButton` or `SecondaryButton` with
  an `icon` prop and `iconPosition="right"`.

To see examples of code in v4 versus v5, see our
[codemod tests](../../codemod/lib/v5/spec/recategorizeButtons.spec.ts).

#### Exports

We've changed some of the Button module's export behavior:

- 🤖 The `beta_Button` export was removed. The codemod will rename the import to `Button` instead,
  preserving local renaming if it exists.

  ```tsx
  // v4
  import {beta_Button as Button} from '@workday/canvas-kit-react-button';

  // v5
  import {SecondaryButton} from '@workday/canvas-kit-react/button';
  ```

- 🤖 The default export was removed. The codemod will change default imports to named imports.

  ```tsx
  // v4
  import Button from '@workday/canvas-kit-react-button';

  // v5
  import {SecondaryButton} from '@workday/canvas-kit-react/button';
  ```

#### Enums

Enums have been removed from all buttons in favor of string literals.

🤖 The codemod will rewrite any usages of an enum to the string literal. If you used an enum as a
type, the codemod will expand to a union of string literals. You could change the union manually
instead to be something like `SecondaryButtonProps['variant']` if you prefer not to duplicate the
union of string literals.

```tsx
// v4
<Button size={Button.Size.Large} />;
interface Props {
  size: ButtonSize;
}

// v5
<SecondaryButton size="large" />;
interface Props {
  size: 'small' | 'medium' | 'large';
}
```

#### createComponent

Buttons now use the `createComponent` utility from the `common` module which forwards `ref` and
allows `as` to change the underlying element.

```tsx
// v4
<Button buttonRef={ref} />;

// v5
<SecondaryButton ref={ref} />;
```

🤖 The codemod will update all buttons to use `ref` instead of `buttonRef`.

Button prop interfaces no longer extend directly from
`React.ButtonHTMLAttributes<HTMLButtonElement>`. `createComponent` returns a component that
determines the element interface via the `as` prop. This is why Button props no longer contain an
element interface directly. If you extend from a Button prop interface, or have code that uses a
Button prop interface and accesses properties like `onClick`, you'll need to provide the button
attribute yourself in order to avoid TypeScript issues (this doesn't affect runtime). This is not
code-moddable since intent cannot be pre-determined.

```tsx
interface MyButtonProps extends ButtonProps {}

// onClick no longer exists in `ButtonProps`, so TypeScript will complain about onClick not
// existing in `MyButtonProps` (`onClick` does exist as a prop on `<Button>`, however)
const MyButton = ({children, onClick}: MyButtonProps) => (
  <Button onClick={onClick}>{children}</Button>
);

// After
interface MyButtonProps extends ButtonProps, React.ButtonHTMLAttributes<HTMLButtonElement> {}

// After (alternate fix)
interface MyButtonProps extends ButtonProps {
  onClick?: React.MouseEventHandler<HTMLButtonElement>;
}
```

### Card

Card is now a [compound component](./COMPOUND_COMPONENTS.mdx) composed of a `Card.Body` and an
optional `Card.Heading`. This allows direct access to the heading and body elements.

```tsx
// v4
<Card header="Card Title" headerId="header-id">
  Card Body
</Card>

// v5
<Card>
  <Card.Heading id="header-id">Card Title</Card.Heading>
  <Card.Body>Card Body</Card.Body>
</Card>
```

🤖 The codemod will attempt to rewrite your JSX to match the new API. Based on what we've seen of
how Card has been used, the codemod should handle most of your use cases. It will work if you rename
`Card` in the import or style the Card using `styled(Card)`:

```tsx
// Handled by the codemod

// Default import
import Card from '@workday/canvas-kit-react-card'

<Card header="Card Title">Card Body</Card>

// Renamed import
import {Card as CanvasCard} from '@workday/canvas-kit-react-card'

<CanvasCard header="Card Title">Card Body</CanvasCard>

// Styled card
import {Card} from '@workday/canvas-kit-react-card'

const StyledCard = styled(Card)(styles)

<StyledCard header="Card Title">Card Body</StyledCard>
```

However, the codemod will _not_ work in cases where `header` or `headerId` are spreaded as props or
if you're importing a re-exported Canvas Kit Card:

```tsx
// NOT handled by the codemod

// Spread props
import {Card} from '@workday-canvas-kit-card'

const props = {
  header: 'Card Title'
}
<Card {...props}>Card Body</Card>

// Re-exporting
import {Card} from './Card' // where `Card` is a re-exported Canvas Kit `Card`
```

### Inputs

All input components in the Main package now support
[ref forwarding](https://reactjs.org/docs/forwarding-refs.html) through use of the `createComponent`
utility from the `common` module. This includes:

- Checkbox
- Color Input
- Color Preview
- Radio
- Select
- Switch
- Text Input
- Text Area

Additionally, the Select in Preview (formerly in Labs) has also been updated to support ref
forwarding.

Most of these input components previously supported an `inputRef` prop that could be used to obtain
a ref to the component's underlying input element. For example, in v4, if you wanted to obtain a ref
to a Text Input's underlying `<input type="text" />` element, you could pass a ref to the component
using `inputRef`. In v5, you'll need to use `ref` instead of `inputRef`:

```tsx
const ref = React.useRef(null);

// v4
<TextInput inputRef={ref} />;

// v5
<TextInput ref={ref} />;
```

🤖 The codemod will update all input components that previously supported `inputRef` to use `ref`
instead.

For components that previously supported `inputRef`, `ref` is now forwarded to the same underlying
element that `inputRef` was applied to previously. Select and Select (Preview) did not support
`inputRef` in v4, but now support `ref` in v5. See each component's documentation for information on
which element `ref` is forwarded to for that particular component.

Input component prop interfaces no longer extend directly from their underlying element interface
(e.g., `TextInputProps` no longer extends from `React.InputHTMLAttributes<HTMLInputElement>`).
`createComponent` returns a component that determines the element interface via the `as` prop. This
is why input component props no longer contain an element interface directly. If you extend from an
input component prop interface, or have code that uses an input component prop interface and
accesses properties like `onClick`, you'll need to provide the input attribute yourself in order to
avoid TypeScript issues (this doesn't affect runtime). This is not code-moddable since intent cannot
be pre-determined.

```tsx
interface MyTextInputProps extends TextInputProps {}

// onClick no longer exists in `TextInputProps` so TypeScript will complain about onClick not
// existing in `MyTextInputProps` (onClick does exist as a prop on `<TextInput>`, however)
const MyTextInput = ({onClick}: MyTextInputProps) => <TextInput onClick={onClick} />;

// Fix
interface MyTextInputProps extends TextInputProps, React.InputHTMLAttributes<HTMLInputElement> {}

// Alternate fix
interface MyTextInputProps extends TextInputProps {
  onClick?: React.MouseEventHandler<HTMLInputElement>;
}
```

As a final note, the following input components were previously class components and, thus,
technically supported the `ref` attribute in v4:

- Color Input
- Color Preview
- Select
- Select (Preview)
- Text Input
- Text Area

Passing `ref={ref}` to any of these components in v4 would have set `ref.current` to the mounted
instance of the entire component
([source](https://reactjs.org/docs/refs-and-the-dom.html#accessing-refs)) rather than the underlying
HTML element represented by the component. This is no longer the case in v5.

### Tabs

In addition to [promoting Tabs](#promotions-from-labs-to-main) out of Labs and into the Main module,
we've made a few updates to the component in v5:

- `onTabsChange` is now `onActivateTab` and the signature is now:
  ```tsx
  function onActivateTab({data: {tab: string}, state: TabsState}): void;
  ```
- The `Tabs` component no longer accepts the `currentTab` property. Tabs uses a model now. See the
  component documentation for more details.

### Popper

In v4, Popper rendered an empty `div` element as a child of the element created by the `PopupStack`
and applied `ref` and `elemProps` (extra props) to that `div` element.

We've updated Popper in v5 to instead apply `ref` directly to the element created by the
`PopupStack`. The `PopupStack` is not React-specific; there is no easy way to spread extra props to
this element as we do for other components, so we've discarded `elemProps`. If necessary, you can
still target the element using `ref` and modify it using DOM APIs.

There is no codemod for this change.

### Popups

Popup has transitioned to a [compound component](./COMPOUND_COMPONENTS.mdx), along with all
Popup-based behavior hooks. What was a `Popup` in v4 is now a `Popup.Card` in v5. The target button
and `Popper` components have also been converted to subcomponents of `Popup`.

#### v4

```tsx
import React from 'react';

import {Button, DeleteButton} from '@workday/canvas-kit-react-button';
import {
  Popper,
  Popup,
  usePopup,
  useCloseOnEscape,
  useCloseOnOutsideClick,
} from '@workday/canvas-kit-react-popup';

export const MyPopup = () => {
  const {targetProps, closePopup, popperProps, stackRef} = usePopup();

  useCloseOnOutsideClick(stackRef, closePopup);
  useCloseOnEscape(stackRef, closePopup);

  const onDeleteClick = () => {
    closePopup();
    console.log('Delete');
  };

  return (
    <>
      <DeleteButton {...targetProps}>Delete Item</DeleteButton>
      <Popper placement={'bottom'} {...popperProps}>
        <Popup
          width={400}
          heading={'Delete Item'}
          padding={Popup.Padding.s}
          handleClose={closePopup}
        >
          <p>Are you sure you'd like to delete the item titled 'My Item'?</p>

          <DeleteButton onClick={onDeleteClick}>Delete</DeleteButton>
          <Button onClick={closePopup}>Cancel</Button>
        </Popup>
      </Popper>
    </>
  );
};
```

#### v5

```tsx
import React from 'react';

import {DeleteButton} from '@workday/canvas-kit-react/button';
import {
  Popup,
  usePopupModel,
  useCloseOnEscape,
  useCloseOnOutsideClick,
  useInitialFocus,
  useReturnFocus,
} from '@workday/canvas-kit-react/popup';

export const MyPopup = () => {
  const model = usePopupModel();

  useCloseOnOutsideClick(model);
  useCloseOnEscape(model);
  useInitialFocus(model); // new
  useReturnFocus(model); // new

  const onDeleteClick = () => {
    console.log('Delete');
  };

  return (
    <Popup model={model}>
      <Popup.Target as={DeleteButton}>Delete Item</Popup.Target>
      <Popup.Popper placement={'bottom'}>
        <Popup.Card width={400} padding="s">
          <Popup.CloseIcon aria-label="Close" />
          <Popup.Heading>Delete Item</Popup.Heading>
          <Popup.Body>
            <p>Are you sure you'd like to delete the item titled 'My Item'?</p>

            <Popup.CloseButton as={DeleteButton} onClick={onDeleteClick}>
              Delete
            </Popup.CloseButton>
            <Popup.CloseButton>Cancel</Popup.CloseButton>
          </Popup.Body>
        </Popup.Card>
      </Popup.Popper>
    </Popup>
  );
};
```

Most notably, `Popup` is now a container component that takes a `PopupModel` and has several
subcomponents like `Popup.Target` and `Popup.CloseButton`. These components are hooked up to the
`PopupModel` via React context and have access to state and events. `Popup.Card` is what the v4
`Popup` once was.

All behavior hooks, like `useCloseOnEscape` now take a `model` instead of variable parameters. This
allowed us to fix some subtle bugs. Using the `PopupModel` means all hooks have access to all Popup
state and events without passing in many parameters.

#### usePopup and usePopupModel

As shown in the example above, `usePopupModel` should now be used instead of `usePopup`. All
subcomponents have an associated behavior hook. For example, `Popup.Target` uses a hook called
`usePopupTarget`. If you need to use your own components for any reason, these hooks are available.
`Popup.Target` and `Popup.CloseButton` do not include any styling. They both render
`SecondaryButton` by default. You can change this via the `as` prop. For example, the following will
render an unstyled button:

```tsx
<Popup.Target as="button">Show</Popup.Target>
```

Pass a `css` prop or a styled button instead to have a custom styled button. You could even pass
`IconButton` if you need an icon button to show a Popup instead!

If you were using `usePopup` before, here's a list of equivalent APIs:

| Before                                                                  | After                                 |
| ----------------------------------------------------------------------- | ------------------------------------- |
| `const { popperProps, targetProps, closePopup, stackRef } = usePopup()` | `const model = usePopupModel()`       |
| `popperProps.open`                                                      | `model.state.visibility !== 'hidden'` |
| `closePopup()`                                                          | `model.events.hide()`                 |
| `stackRef` or `popperProps.ref`                                         | `model.state.stackRef`                |
| `popperProps.anchorElement`                                             | `model.state.targetRef.current`       |
| `targetProps.onClick`                                                   | `usePopupTarget(model).onClick`       |

#### New Focus Management

A common theme we noticed in uses of Popup in the wild was focus management. Developers were
manually passing a `ref` to the target button element and manually returning focus to it when
closing the Popup. This use case should now be handled by the new `useReturnFocus` hook. By default,
`useReturnFocus` will return focus to the `targetRef` in the model, which is set by `Popup.Target`.
This can be overridden by passing `returnFocusRef` to the model on creation. `returnFocusRef` should
make your migration easier if `Popup.Target` cannot be used for whatever reason.

```tsx
// before
const {closePopup} = usePopup();

// passed to some event handler
const closeAndReturnFocus = () => {
  closePopup();
  buttonRef.current.focus();
};

// after
const model = usePopupModel({
  returnFocusRef: buttonRef, // only use if you cannot use `Popup.Target`
});

useReturnFocus(model);
```

Another common use case involved focusing something within the Popup when the Popup was shown. The
`useInitialFocus` hook was created for this purpose. `useInitialFocus` will set focus to the first
focusable element when the Popup becomes visible. This behavior can be overridden by passing
`initialFocusRef` to the model.

```tsx
// before
const {stackRef, popperProps} = usePopup();

useLayoutEffect(() => {
  if (!open) {
    return;
  }

  stackRef.current.querySelector('input,...').focus();
}, [popperProps.open]);

// after
const model = usePopupModel({
  initialFocusRef: someRef, // only use if you want to explicitly focus on something. Could be useful for an input.
});

useInitialFocus(model);
```

#### Managing Positioning

If you'd prefer to manage positioning yourself, you can use `Popup.Card` on its own. Without the
model and behaviors, the following is equivalent:

```tsx
// v4
<Popup width={width} handleClose={onClose} heading="Popup Heading">
  Popup Content
</Popup>

// v5
<Popup.Card with={width}>
  <Popup.CloseIcon aria-label="Close" onClick={onClose} />
  <Popup.Heading>Popup Heading</Popup.Heading>
  <Popup.Body>Popup Content</Popup.Body>
</Popup.Card>
```

`Popup.Card` uses `Card`, which is now using `Box`. Consequently, the following props have changed:

| Before                         | After                                      |
| ------------------------------ | ------------------------------------------ |
| `padding={Popup.Padding.zero}` | `padding="zero"` or `padding={space.zero}` |
| `depth={depth[0]}`             | `depth={0}`                                |
| `popupRef={ref}`               | `ref={ref}`                                |

#### Transitioning

We noticed Popups were used in two different ways: always rendering and conditional rendering.

```tsx
// Always rendering
const MyPopup = () => {
  const targetRef = React.useRef(null)
  const {stackRef, popperProps, targetProps, closePopup} = usePopup()

  const handleClose = () => {
    closePopup()
    targetRef.current.focus() // focus back on target
  }

  useCloseOnEscape(stackRef, handleClose)

  return (
    <>
      <button ref={targetRef} {...targetProps}>Open</button>
      <Popper {...popperProps}>
        <Popup>
          {/* content */}
          <button onClick={handleClose}>Close</button>
        </Popup>
      </Popper>
    </>
  )
}

// Conditional rendering
const MyOpenPopup = ({onClose, targetRef}) => {
  const {popperProps, closePopup} = usePopup()

  const handleClose = () => {
    onClose()
    closePopup()
    targetRef.current.focus() // focus back on target
  }

  useCloseOnEscape(stackRef, handleClose)

  return (
    <Popper {...popperProps}>
      <Popup>
        {/* content */}
        <button onClick={handleClose}>
      </Popup>
    </Popper>
  )
}

const MyPopup = () => {
  const targetRef = React.useRef(null)
  const [open, setOpen] = React.useState(false)

  const onClose = () => {
    setOpen(false)
  }

  return (
    <>
      <button ref={targetRef} onClick={() => { setOpen(true) }}>
      {open && <MyOpenPopup onClose={onClose} />}
    </>
  )
}
```

The difference between the two is subtle, but in the always rendering example, the `usePopup` hook
runs on every render. In the conditional rendering example, the `usePopup` hook only runs when
`MyPopup` renders it. This means hooks like `useCloseOnEscape` need to function properly in both
cases, but `open` is not passed to the hook. This caused subtle bugs. Now, `useCloseOnEscape` is
passed a `PopupModel` which has access to the popup's visible state. `useCloseOnEscape` will now
only run when the popup is visible, but this means the conditional rendering example will have to do
extra work because the `target` is out of scope of the `MyOpenPopup` component. The following is
equivalent to the example in v5:

```tsx
const MyOpenPopup = ({onClose, targetRef}) => {
  const model = usePopupModel({
    initialVisibility: 'visible', // needed for `useCloseOnEscape` and other hooks
    returnFocusRef: targetRef, // determines where return focus goes
  })

  useCloseOnEscape(model)
  useReturnFocus(model) // handles return focus

  return (
    <Popup>
      <Popup.Popper>
        <Popup.Card>
          {/* content */}
          <Popup.CloseButton as="button">Close</Popup.CloseButton>
        </Popup>
      </Popper>
    </Popup>
  )
}

const MyPopup = () => {
  const targetRef = React.useRef(null)
  const [open, setOpen] = React.useState(false)

  const onClose = () => {
    setOpen(false)
  }

  return (
    <>
      <button ref={targetRef} onClick={() => { setOpen(true) }}>
      {open && <MyOpenPopup onClose={onClose} />}
    </>
  )
}
```

### Skeleton

Skeleton was already implemented as a compound component in v4, but we've made changes to its
imports and to its animation in v5.

The imports for its subcomponents in v4 (`SkeletonHeader`, `SkeletonText`, and `SkeletonShape`) have
been converted to keys on `Skeleton` in v5 (`Skeleton.Header`, `Skeleton.Text`, and
`Skeleton.Shape`). You only need to import the `Skeleton` component in v5, and you may still compose
your own Skeleton using whatever parts you need.

```tsx
// v4
import {
  Skeleton,
  SkeletonHeader,
  SkeletonShape,
  SkeletonText,
} from '@workday/canvas-kit-react/skeleton';
const MySkeleton = () => (
  <Skeleton>
    <SkeletonHeader />
    <SkeletonText />
    <SkeletonShape width={40} height={40} />
  </Skeleton>
);

// v5
import {Skeleton} from '@workday/canvas-kit-react/skeleton';
const MySkeleton = () => (
  <Skeleton>
    <Skeleton.Header />
    <Skeleton.Text />
    <Skeleton.Shape width={40} height={40} />
  </Skeleton>
);

Additionally, the skeleton animation has been updated from a diagonal sheen, or shimmer, to fading
the opacity of the entire shape(s) in and out.
