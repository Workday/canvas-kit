import {Meta} from '@storybook/addon-docs';

<Meta title="Welcome/Migration Guides/v7.0" />

# Canvas Kit 7.0 Migration Guide

Below are the breaking changes made in Canvas Kit v7. Please
[reach out](https://github.com/Workday/canvas-kit/issues/new?labels=bug&template=bug.md) if you have
any questions about the update.

- [Codemod](#codemod)
- [Infrastructure](#infrastructure)
- [Component Deprecations](#component-deprecations)
- [Component Promotions](#component-promotion)
- [Buttons](#buttons)
- [Segmented Control](#segmented-control)
- [Side Panel](#side-panel)
- [Icons](#icons)
- [ActionBar Component Updates](#actionbar-component-updates)
- [Status Indicator Width](#status-indicator-width)
- [Popup Cards](#popup-cards)
- [Popper Props Update](#popper-props-update)
- [Component Promotions](#component-promotion)
- [Model Changes](#model-changes)
- [Token Updates](#token-updates)
  - [Depth Tokens](#depth-tokens)

## Codemod

Please use our [codemod package](https://github.com/Workday/canvas-kit/tree/master/modules/codemod)
to automatically update your code to work with a majority of the breaking changes in the migration
from Canvas Kit v6 to v7:

```sh
> npx @workday/canvas-kit-codemod v7 [path]
```

> Note: This codemod only works on `.js`, `.jsx`, `.ts`, and `.tsx` extensions. You may need to make
> some manual changes in other file types (`.json`, `.mdx`, `.md`, etc.).

> Note: You may need to run your linter after executing the codemod, as it's resulting formatting
> (spacing, quotes, etc.) may not match your project's styling.

**Breaking changes accounted for by this codemod will be marked with a ðŸ¤–.**

**Please verify all changes made by the codemod. As a safety precaution, we recommend committing the
changes from the codemod as a single isolated commit (separate from other changes) so you can
rollback more easily if necessary.**

[Let us know](https://github.com/Workday/canvas-kit/issues/new?labels=bug&template=bug.md) if you
encounter any issues or use cases that we've missed. The `@workday/canvas-kit-codemod` package will
help us maintain additional codemod transforms to make future migrations easier.

## Infrastructure

## Infrastructure Upgrades

Breaking:

- v7 now requires Typescript 4.1 and has dropped support for Typescript 3.5-3.9. Previously we used
  `downlevel-dts` to support Typescript 3.5+ while using Typescript 3.8 features, but
  `downlevel-dts` does not support the Typescript 4.1 features we use. Typescript 4.1 was release in
  November, 2020 and we feel it is time to move forward. Reach out if you experience issues
  upgrading your Typescript version. In our experience, Typescript 4.1 found a few more errors that
  Typescript 3.8 did not, but the upgrade was manageable.

## Component Deprecations

### Deprecation Types

There are two types of deprecations: soft and hard.

#### Soft Deprecation

A soft-deprecated component is still available with its full functionality, but it will have been
renamed with a prefix to indicate its soft-deprecated status. It will also include a console warning
to announce its deprecation. This warning will only be triggered on the component's initial render.

Soft-deprecated types and utilities will also be renamed but generally will not trigger a console
warning.

#### Hard Deprecation

A hard-deprecated component or package is no longer available. You will need to follow the method
prescribed in our migration guide to update your application. Please reach out to our team directly
if you need additional help.

### Cookie Banner

We are [hard deprecating](#hard-deprecation) `CookieBanner`. If you would like to migrate away from
this deprecated component now, you can reference
[this example](https://workday.github.io/canvas-kit/?path=/story/examples-cookiebanner-react--basic)

### Page Header

We are [hard deprecating](#hard-deprecation) `Page Header`. If you would like to migrate away from
this deprecated component now, you can reference
[this example](https://workday.github.io/canvas-kit/?path=/story/examples-pageheader-react--basic)

### Header / GlobalHeader

We are [hard deprecating](#hard-deprecation) `Header`. If you would like to migrate away from this
deprecated component now, you can reference
[this example](https://workday.github.io/canvas-kit/?path=/story/examples-globalheader-react--basic)

## ActionBar Component Updates

The ActionBar API changed to model API to support more generic behaviors to allow for other
components to support responsive layouts using the same models and behaviors. It also allows to
implement a responsive layout based on a container width
([#1325](https://github.com/Workday/canvas-kit/pull/1585)).

````
const model = useActionBarModel({
  items: [{
    id: 'first,
    text: 'First Action',
    onClick: () => console.log('first clecked')
  }]
});

<ActionBar model={model} />

The ActionBar component can now handle responsive containers, but the support is not automatic. You must
use the dynamic API, `showOverflowButton` prop in `ActionBar.List` and provide an overflow menu subcomponent.
The dynamic API doesn't know the shape of your object, so render props must be used to instruct React how to render each item.

```
const [items] = React.useState<MyActionItem[]>([
  {id: 'first', text: 'First Button', onClick: () => console.log('first button clicked')},
  {id: 'second', text: 'Second Button', onClick: () => console.log('second button clicked')},
  {id: 'third', text: 'Third Button', onClick: () => console.log('third button clicked')},
  {id: 'fourth', text: 'Fourth Button', onClick: () => console.log('fourth button clicked')},
  {id: 'fifth', text: 'Fifth Button', onClick: () => console.log('fifth button clicked')},
]);

const model = useActionBarModel({items});

<ActionBar model={model}>
  <ActionBar.List showOverflowButton={true}>
    {(item) => <ActionBar.Item data-id={item.id}>{item.text}</ActionBar.Item>}
  </ActionBar.List>
  <ActionBar.Menu.Popper>
    <ActionBar.Menu.Card maxWidth={300} maxHeight={200}>
      <ActionBar.Menu.List>
        {(item) => <ActionBar.Menu.Item>{item.text}</ActionBar.Menu.Item>}
      </ActionBar.Menu.List>
    </ActionBar.Menu.Card>
  </ActionBar.Menu.Popper>
</ActionBar>
```

ðŸ¤– The codemod will remove uses of the `fixed` prop from `ActionBar` and restructure component by
creating `ActionBar.List` component and replacing all children to it.

## Status Indicator Width

Status Indicators currently truncate when they reach their max width of `150px`. After receiving
requests to increase this, we have upped it by 25% to `200px`.

We've also added a prop (`maxWidth`) to configure this if you need to. While this increases
flexibility, please keep in mind that status text should be short, direct, and preferably a single
word.

```tsx
<StatusIndicator label="Slightly Longer Status" type={StatusIndicator.Type.Gray} maxWidth={250} />
````

## Buttons

To consolidate button APIs, we removed `IconButton` in favor of `PrimaryButton`, `SecondaryButton`
and `TertiaryButton`.

### Breaking Changes

- Removed the `toggled` prop when migrating from `IconButton`
- Changed the values of `IconPosition: left | right` - > `IconPosition: start | end`
- Remove `dataLabel` prop from `PrimaryButton` and `SecondaryButton`

ðŸ¤– The codemod will handle all these changes automatically:

- `iconPosition='left'` becomes `iconPosition='start'`
- `iconPosition='right'` becomes `iconPosition='end'`
- `<IconButton icon={plusIcon} />` becomes `<TertiaryButton icon={plusIcon} />`
- `<IconButton variant='circleFilled' icon={plusIcon} />` becomes
  `<SecondaryButton icon={plusIcon} />`
- `<IconButton variant='inverse' icon={plusIcon} />` becomes
  `<TertiaryButton variant='inverse' icon={plusIcon} />`
- `<IconButton variant='inverseFilled' icon={plusIcon} />` becomes
  `<SecondaryButton variant='inverseFilled' icon={plusIcon} />`

#### Manual Changes

The following changes will not be automatic updated and will require a manual update:

- Remove `IconButton` variants: `plain`, `square`, and `squareFilled`
- Remove `IconButtonProps`
- Remove `IconButton` prop: `toggled`
- Remove `PrimaryButton` and `SecondaryButton` prop: `dataLabel`

### Button Mapping

Below is a mapping of V6 `IconButton` variants to their respective V7 buttons and variants. Further
below is a description of how to manually migrate from unsupported V6 variants. | IconButton variant
| Button Type | | ------------------ | ------------------------------------ | | `circle` |
TertiaryButton | | `circleFilled` | SecondaryButton | | `inverse` | TertiButton with variant inverse
| | `inverseFilled` | SecondaryButton with variant inverse | | `plain` | Not Supporting | | `square`
| Not Supporting | | `squareFilled` | Not Supporting |

### Remove `IconButton` `plain`, `square`, and `squareFilled` Variants

As part of simplifying our variants and cleaning up the API, we've removed the variants `square`,
`squareFilled` and `plain`. We've also removed the prop `toggled`.

Plain, Square, or Square-Filled Icon Buttons should either transition to the new icon only Primary,
Secondary, and Tertiary button variants, the Toolbar Icon Button, or the Segmented Control component

If you would still like to have a squared icon, you can use
[ToolbarIconButton](https://workday.github.io/canvas-kit/?path=/docs/components-buttons-button-react-toolbar--toolbar-icon-button)
which also has the `toggled`prop.

If this button doesn't fit your specific use case, we've introduced a low level
[`BaseButton` component](#basebutton-component). This component allows you to modify the colors,
props, and size of the button. For an example of this being used, you can reference our
[PageButton component](https://github.com/Workday/canvas-kit/blob/master/modules/react/pagination/lib/Pagination/PageButton.tsx).

### Rendering an icon button

In order to render a icon button, omit any `children` and pass the button an `icon` prop.

Example

v6

```tsx
<IconButton variant="circleFilled" icon={plusIcon} />
```

v7

```tsx
<SecondaryButton icon={plusIcon} />
```

You can now render what use to be an `IconButton` using our main buttons.

```tsx
<PrimaryButton icon={plusIcon} />
<SecondaryButton icon={plusIcon} />
<TertiaryButton icon={plusIcon} />
<PrimaryButton variant='inverse' icon={plusIcon} />
<SecondaryButton variant='inverse' icon={plusIcon} />
<TertiaryButton variant='inverse' icon={plusIcon} />
```

### Button sizes

Each button now supports sizes: `extraSmall`, `small`, `medium` and `large` with `medium` being the
default size.

```tsx
  <PrimaryButton icon={plusIcon} size='extraSmall' />
  <PrimaryButton icon={plusIcon} size='small' />
  <PrimaryButton icon={plusIcon} size='medium' /> // default
  <PrimaryButton icon={plusIcon} size='large' />
```

### Button Icon position

The prop `iconPosition` which is used to determine which side an icon should be when rendered with
some text, has been changed. The default is `start`

v6

```tsx
iconPosition: 'left' | 'right';
```

v7

```tsx
iconPosition: 'start' | 'end';
```

_Note:_ The position of the icon should have no affect if you're rending an icon button.

### Removal of `dataLabel` Prop

The `dataLabel` prop has been removed from our Buttons in v7 in order to simplify the API.

_Note:_ The codemod will not remove this prop since use of this prop varies. If you'd like to still
have a similar effect, below is an example of how to achieve this.

v6

```tsx
<PrimaryButton dataLabel="1:00">Time</PrimaryButton>
```

v7

```tsx
<PrimaryButton>
  Time
  <span
    style={{
      position: 'relative', // Fixes an IE issue with text within button moving on click
      textOverflow: 'ellipsis',
      overflow: 'hidden',
      whiteSpace: 'nowrap',
      fontWeight: 400,
      marginLeft: 4,
    }}
  >
    1:00
  </span>
</PrimaryButton>
```

### BaseButton Component

As part of the restructure of our Buttons, we've created a low level `BaseButton` component. This
component isn't intended to be used outside of Canvas Kit, but we do export it for very specific use
cases which we'll outline below. The `BaseButton` is a styled `button` element which extends our
style properties which allow us to customize a buttons `colors`, `padding`, `width` and other style
properties.

Basic example:

```tsx
import * as React from 'react';
import {colors} from '@workday/canvas-kit-react/tokens';
import {BaseButton} from '@workday/canvas-kit-react/button';
import {plusIcon} from '@workday/canvas-system-icons-web';

const getBasicButtonColors = () => {
  return {
    default: {
      background: colors.blueberry400,
      label: colors.frenchVanilla100,
      icon: colors.frenchVanilla100,
    },
    hover: {
      background: colors.blueberry500,
      label: colors.frenchVanilla100,
      icon: colors.frenchVanilla100,
    },
    active: {
      background: colors.blueberry500,
      label: colors.frenchVanilla100,
      icon: colors.frenchVanilla100,
    },
    focus: {
      background: colors.blueberry400,
      label: colors.frenchVanilla100,
      icon: colors.frenchVanilla100,
    },
    disabled: {
      background: colors.blueberry400,
    },
  };
};

export type BasicButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & {};

export const BasicButton = ({children, ...elemProps}: BasicButtonProps) => {
  return (
    <BaseButton
      colors={getPaginationButtonColors(toggled)}
      {...elemProps}
    >
      <BaseButton.Label>{children}</BaseButton.Label>
      <BaseButton.Icon icon={plusIcon}>
    </StyledToggleButton>
  );
};
```

**Note:** Under the hood, `BaseButton` uses our `Box` component which allows `BaseButton` to accept
style properties. Because of the flexibility of this component, consumers can use this to create
toggled buttons or a specific button that doesn't fall under the main use case you see in our design
system.

**Disclaimer** We strongly advise consumers not to use this component if possible and to rely on our
`PrimaryButton`, `SecondaryButton` and `TertiaryButton` when possible.

## Segmented Control

Segmented Control use to work when rendering `IconButton` as children. This has now moved to a
compound component and removed the use of `IconButton`.

### Breaking Change

`IconButton` is no longer a valid child of segmented control.

ðŸ¤– The codemod will handle all these changes automatically:

- `IconButton` becomes `SegmentedControl.Button`

v6

```tsx
<SegmentedControl value={value} onChange={handleToggle}>
  <IconButton
    icon={listViewIcon}
    value="list-view"
    aria-label="List View"
    onClick={e => console.log('Existing IconButton onClick callback')}
  />
  <IconButton icon={worksheetsIcon} value="table-view" aria-label="Table View" disabled={true} />
  <IconButton icon={deviceTabletIcon} value="device-view" aria-label="Device View" />
  <IconButton icon={percentageIcon} value="percent-view" aria-label="Percent View" />
</SegmentedControl>
```

v7

```tsx
<SegmentedControl value={value} onChange={handleToggle}>
  <SegmentedControl.Button
    icon={listViewIcon}
    value="list-view"
    aria-label="List View"
    onClick={e => console.log('Existing IconButton onClick callback')}
  />
  <SegmentedControl.Button
    icon={worksheetsIcon}
    value="table-view"
    aria-label="Table View"
    disabled={true}
  />
  <SegmentedControl.Button icon={deviceTabletIcon} value="device-view" aria-label="Device View" />
  <SegmentedControl.Button icon={percentageIcon} value="percent-view" aria-label="Percent View" />
</SegmentedControl>
```

## Side Panel

The `SidePanel` in our `preview` package has now been updated so that the toggle button has a
tooltip built in. If you currently have a `Tooltip` component wrapping this element, you should
remove it and provide the appropiate text to the button based on its state.

Two props where added to the `SidePanel.ToggleButton`:

```tsx
/**
   * The tooltip text to expand the side panel
   * @default 'Expand'
   */
  tooltipTextExpand?: string;
  /**
   * The tooltip text to collapse the side panel
   * @default 'Collapse'
   */
  tooltipTextCollapse?: string;
```

## Icons

We've updated our lower level icon components such as `AccentIcon`, `AppletIcon`, `Graphic`, `Icon`,
`Svg`, `SystemIcon`, and `SystemIconCircle` to use our
[createComponent](https://github.com/Workday/canvas-kit/blob/ff77c5bd83e41c3ab2b9c55e41a8b7c1fde33a1b/modules/react/common/lib/utils/components.ts#L167)
which allows us to `forwardRef`.

### Breaking Change

This is a breaking change since we've removed `iconRef`. You can now just pass a `ref` to the
element.

ðŸ¤– The codemod will handle all these changes automatically:\

- `iconRef` becomes `ref`

## Popup Cards

`Popup.Card` (this includes `Modal.Card` and `Dialog.Card`) components are now a flexbox container.
This was done to support overflowing content (by default, the `Popup.Body` component). The idea is
the card is a vertical flexbox container and the `Popup.Heading`, `Popup.Body`, and any other
children are flex items. The `Popup.Body` now has an `overflow-y: auto` on it to naturally allow the
body content to overflow in a scroll container. This is a breaking change if your `Popup`, `Modal`,
or `Dialog` doesn't work with a flexbox with `flex-direction: column`. In most cases, this shouldn't
matter. If this change does cause your popup to display correctly, you may need to play around with
flex item containers.

An example where this might break:

A common Modal has a heading, body, and footer (Cancel/Submit buttons). If the Cancel and Submit
buttons are direct children of the `Modal.Card` like the following:

```tsx
<Modal.Card>
  <Modal.Heading>Some Heading</Modal.Heading>
  <Modal.Body>Some Body</Modal.Body>
  <SecondaryButton>Cancel</SecondaryButton>
  <PrimaryButton>Submit</PrimaryButton>
</Modal.Card>
```

The buttons will become vertical flex items instead of the default which is displaying inline-block.
Before, the buttons would layout next to each other horizontally. After, the buttons will stack
vertically. To fix this, you'll have to add another element to be a flex item from the `Modal.Card`.
Our examples use `HStack` to align the buttons. The following will render correctly after this
change:

```tsx
<Modal.Card>
  <Modal.Heading>Some Heading</Modal.Heading>
  <Modal.Body>Some Body</Modal.Body>
  <HStack spacing="s">
    <SecondaryButton>Cancel</SecondaryButton>
    <PrimaryButton>Submit</PrimaryButton>
  </HStack>
</Modal.Card>
```

If your code contains any hacks to make a `Modal` overflow, these hacks should now be removed.
[This example shows how body content overflows](https://workday.github.io/canvas-kit/?path=/docs/components-popups-modal-react--body-overflow)
(you may have to limit your browser height to see the overflow). Before you had to manually set the
`max-height` of the `Modal.Body` element using calculations. These should be removed. The
`Popup.Card` now has a max height and the `Popup.Body` height is automatically calculated.

### Popup.Body

The `Popup.Body` is now an overflow container. This means 2 things:

- `Popup.Body` will scroll if the contents are too big to fit in the page
- `Popup.Body` will hide focus rings that render outside the overflow container

Our examples contained some buttons inside the `Body` element and had focus rings cut off. The
adjustment is to move the buttons outside the `Body` element. This is most likely the desired
structure anyways since the buttons will not scroll with the overflowed `Body` content.

Before:

```tsx
<Modal.Card>
  <Modal.Body>
    Body Contents
    <HStack spacing="s">
      {/*will scroll with the body*/}
      <Modal.CloseButton as={PrimaryButton}>Delete</Modal.CloseButton>
      <Modal.CloseButton>Cancel</Modal.CloseButton>
    </HStack>
  </Modal.Body>
</Modal.Card>
```

After:

```tsx
<Modal.Card>
  <Modal.Body>Body Contents</Modal.Body>
  <HStack spacing="s">
    <Modal.CloseButton as={PrimaryButton}>Delete</Modal.CloseButton>
    <Modal.CloseButton>Cancel</Modal.CloseButton>
  </HStack>
</Modal.Card>
```

## Popper Props Update

We removed the `containerElement` prop from Popper component because it's no longer needed with
Fullscreen API.

## Component Promotions

After some [assessment](https://github.com/Workday/canvas-kit/issues/1395) we've decided to promote
the following components: `Flex`, `Stack`, `Box` and `Breadcumbs`

This promotion does not introduce any API changes, we've just changed moved the components to our
main `react` package.

**Changes:**

- `Box` was promoted from `@workday/canvas-kit-labs/common` to `@workday/canvas-kit-react/layout`
- `Flex` was promoted from `@workday/canvas-kit-labs/layout` to `@workday/canvas-kit-react/layout`
- `Stack` was promoted from `@workday/canvas-kit-labs/layout` to `@workday/canvas-kit-react/layout`

## Model Changes

### Guards and Callbacks

We changed the signature of model event guards and callbacks. In v6, the parameters were in an
object. This has a less than ideal developer experience as intellisense isn't engaged immediately
and we don't plan on adding any additional parameters to guard and callback functions. We've removed
the object wrapper.

ðŸ¤– The codemod handles these changes automatically.

Before:

```tsx
const model = useTabsModel({
  onSelect({data: {id}, prevState}) {
    console.log(id, prevState);
  },
});
```

After:

```tsx
const model = useTabsModel({
  onSelect({id}, prevState) {
    console.log(id, prevState);
  },
});
```

### Model Implementation

If you don't extend models, you can skip this section.

In v6 we supported Typescript 3.8 which limited the way types could be inferred and defined. Canvas
Kit v7 now requires Typescript 4.1 which introduced
[Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html).
This means that the guards and callbacks no longer need to be manually defined via an `eventMap`.
Event maps were a stopgap, were manual, and prone to errors in defining them. Not all events had
guards or callbacks there's no check other than manual review to ensure the existence of an event
callback or guard. Template Literal Types allow us to properly type guards and callbacks without
event maps. The previous types forced `data` to be an object. We've since dropped that restriction.
You can still only pass a single argument to events. If you need additional information, use an
object.

This change also allowed us to remove a lot of boilerplate associated with models without
sacrificing type safety. This change doesn't effect most use cases, but will effect those whole
extended a model. We created a new utility function called `createModelHook` that helps set up
types.

Before:

```ts
export type MyState = {
  value: string;
};

export type MyEvents = {
  updateValue(data: {value: string}): void; // enforced that `data` is an object even if we only need to pass a string
};

export type MyModel = Model<MyState, MyEvents>;

export const myEventMap = createEventMap<MyEvents>()({
  guards: {
    shouldUpdateValue: 'updateValue', // easy to forget or make a mistake on guard name
  },
  callbacks: {
    onUpdateValue: 'updateValue',
  },
});

export type MyBaseConfig = {
  initialValue?: string;
};

export type MyConfig = MyBaseConfig & Partial<ToModelConfig<MyState, MyEvents, typeof myEventMap>>;

const useMyModel = (config: MyConfig = {}): MyModel => {
  const [value, setValue] = React.useState(config.initialValue || '');

  const state = {value};

  // useEventMap is used to wrap the event object with guards and callbacks according to the event map
  const events = useEventMap(myEventMap, state, config, {
    updateValue(data) {
      setValue(data.value);
    },
  });

  return {state, events};
};
```

After:

```tsx
const useMyModel = createModelHook({
  defaultConfig: {
    initialValue: '',
  },
})(config => {
  const [value, setValue] = React.useState(config.initialValue); // default is already handled

  const state = {value};

  const events = {
    updateValue(value: string) {
      // doesn't need to be an object anymore
      setValue(value);
    },
  };

  return {state, events};
});
```

Notice the large reduction in Typescript type boilerplate. In this example, the only place that
Typescript syntax exists is in the `updateValue` function definition. This allows better collocating
of types and values. Also notice that `useEventMap` doesn't need to be used anymore. The
`createModelHook` will automatically wrap the `events` returned to call guards and callbacks when
appropriate. Today this is done via creating a new events object. Once we drop IE11 support, this
can be done via a proxy instead. The `createModelHook` handles all type inference so we don't have
to explicitly type everything. Also `createModelHook` attaches React Context directly to the hook
along with `defaultConfig` and `requiredConfig` for model extension.

If you extended a model, you'll notice all those types are no longer being exported. You'll have to
use this new utility function. Here's an example we found in the wild:

```tsx
import {
  BasePopupModelConfig,
  createEventMap,
  Model,
  popupEventMap,
  PopupEvents,
  PopupModelConfig,
  PopupState,
  ToModelConfig,
  useCloseOnEscape,
  useEventMap,
  useFocusTrap,
  useInitialFocus,
  usePopupModel,
  useReturnFocus,
} from '@workday/canvas-kit-react';

type MyModalState = PopupState & {
  showOverlay: boolean;
};

type MyModalEvents = PopupEvents;

const myModalEventMap = createEventMap<MyModalEvents>()({
  guards: {
    ...popupEventMap.guards,
  },
  callbacks: {
    ...popupEventMap.callbacks,
  },
});

type MyBaseModalConfig = BasePopupModelConfig & {
  showOverlay?: boolean;
};

type MyModalModel = Model<MyModalState, MyModalEvents>;

type MyConfig = MyBaseConfig &
  Partial<ToModelConfig<MyModalState, MyModalEvents, typeof myModalEventMap>>;

export const useMyModalModel = (config: MyConfig = {}): MyModalModel => {
  const [showOverlay] = React.useState(config.showOverlay ?? true);

  const model = usePopupModel({
    ...config,
    // hook up to a redux store
    onShow(...params) {
      dispatch(setIsModalOpen(true));
      config?.onShow?.(...params);
    },
    onHide(...params) {
      dispatch(setIsModalOpen(false));
      config?.onShow?.(...params);
    },
  });

  useInitialFocus(model);
  useReturnFocus(model);
  useFocusTrap(model);
  useCloseOnEscape(model);

  const state = {
    ...model.state,
    showOverlay,
  };

  const events = useEventMap(myEventMap, state, config, {
    ...model.events,
  });

  return {state, events};
};
```

After:

```ts
import {
  useCloseOnEscape,
  useEventMap,
  useFocusTrap,
  useInitialFocus,
  usePopupModel,
  useReturnFocus,
} from '@workday/canvas-kit-react';

const useMyModalModel = createModelHook({
  defaultConfig: {
    ...usePopupModel.defaultConfig,
    showOverlay: true,
  },
  requiredConfig: usePopupModel.requiredConfig,
  contextOverride: usePopupModel.Context, // needed to make sure this model uses the same context as the popup model, otherwise it will create a new one
})(config => {
  // `mergeConfig` takes care of the manual merging we were doing earlier
  const model = usePopupModel(
    usePopupModel.mergeConfig(config, {
      // hook up to a redux store
      onShow() {
        dispatch(setIsModalOpen(true));
      },
      onHide() {
        dispatch(setIsModalOpen(false));
      },
    })
  );

  useInitialFocus(model);
  useReturnFocus(model);
  useFocusTrap(model);
  useCloseOnEscape(model);

  const state = {
    ...model.state,
    showOverlay,
  };

  return {...model, state};
});
```

All the cumbersome type boilerplate went away. Also all the type imports went away. The code is more
focused on your unique logic and less on boilerplate. Unfortunately, this change doesn't have a
codemod. While possible, this code isn't very common and the codemod would be very complex.

## Token Updates

### Depth Tokens

**Changes:**

- Depth `inset` was removed from token list.
- Added new depth: `none` (to remove default depth from component), `5` and `6`.
- Updated all depth values: now depth adds only `box-shadow` with 2 shadows and no border.

Also we changed default depth for the following components:

- Card: Depth 2 â†’ Depth 1
- Breadcrumbs Dropdown Menu: Depth 2 â†’ Depth 3
- Menu: Depth 2 â†’ Depth 3
- Combobox: Depth 1 â†’ Depth 3
- Popup: Depth 2 â†’ Depth 5
- Dialog: Depth 2 â†’ Depth 5
- Color Picker Palette: Depth 2 â†’ Depth 5
- Toast: Depth 2 â†’ Depth 5
- Modal: Depth 2 â†’ Depth 6
- Preview Side Panel (alternate variant): Depth 3 â†’ Depth 6
