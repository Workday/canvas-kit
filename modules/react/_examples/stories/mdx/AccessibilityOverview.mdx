import {Flex} from '@workday/canvas-kit-react/layout';
import iconBefore from './assets/icons-before-whcm.png';
import iconAfter from './assets/icons-after-whcm.png';
import checkMark from './assets/checkmarks.png';
import checkMarkWhcm from './assets/checkmarks-whcm.png';
import modalBorder from './assets/modal-border.png';
import tooltipClose from './assets/tooltip-close.png';

<Meta title="Guides/Accessibility/Overview" />

## Canvas Kit Accessibility

Canvas Kit is built with accessibility in mind and we continuously strive to provide a robust set of
accessible components that are easy to customize for your needs. Core concepts and key investments
made by the Canvas Kit development team are introduced in the sections below and throughout this
guide.

## The Accessibility Tree

The Accessibility Tree is created by the web browser from the semantic information provided in the
document object model (DOM). It's like a simplified outline containing only the most important
information: the elements on the page, what they are (e.g., a button, a link, a heading), and what
they do. This tree is what a screen reader uses to tell a person what's on the page and how to
interact with it.

- `name:` a.k.a. “Label” describes the purpose of an element. (E.g. text fields provided for first
  name, last name, and street address.)
- `role:` describes what an element is and how it can be used. (E.g. a text field, radio button
  group, or single checkbox.)
- `state:` describes the current state of an element. (E.g. whether a text field is empty or
  displaying text.)

Further reading:
[Full accessibility tree in Chrome DevTools](https://developer.chrome.com/blog/full-accessibility-tree#main-content)

## Accessible Names and Descriptions

Giving an element an **accessible name** is like giving it a label. It's a short phrase, like
"Search" or "Submit," that a screen reader uses to tell a person what an item is. This helps a user
understand the element's purpose and tell it apart from other items on the page. Some items, like
buttons and links, are required to have an accessible name. You can also add an **accessible
description** if you need to provide more information. This could be instructions for a form field
or a longer explanation of what a button does. A screen reader will read the name first, and then
the description, giving the user all the information they need to understand and use the element.

Further reading:
[Providing Accessible Names and Descriptions | APG | WAI | W3C](https://www.w3.org/WAI/ARIA/apg/practices/names-and-descriptions/)

## `<AccessibleHide>` Component

```
<AccessibleHide>
  This text is hidden using CSS and still available to screen readers.
</Accessibility>
```

## `<AriaLiveRegion>` Component

```
<AriaLiveRegion>
  When this text is updated, screen readers will announce it in live time.
</AriaLiveRegion>
```

Check out our
[Aria Live Region Examples](?path=/docs/guides-accessibility-examples-aria-live-regions--docs) for
more detailed information about this topic.

Sometimes, things change on a webpage without the whole page reloading. Think of a live sports score
that updates every few seconds or a search result that appears as you type. For users of screen
readers, these changes can be missed because the screen reader doesn't know to look for them. This
is where **ARIA live regions** come in. An ARIA live region is a special area on a webpage that
tells a screen reader to pay close attention to it. When the content in this area changes, the
screen reader automatically announces the update to the user. This ensures that everyone, including
those using assistive technology, is kept aware of important, real-time changes on the page.

## `useUniqueId()` Hook

This handy utility function is useful anytime a unique ID is needed for assigning labels,
descriptions, or for anything else in the web application.

```
/**
In this example, we use 'aria-labelledby' on the table container
instead of using HTML <caption> to assign a name for the table.
*/
const tableHeadingId = useUniqueId();
...
<Heading id={tableHeadingId}> Pizza Toppings </Heading>
...
<Table aria-labelledby={tableHeadingId}>
  /* table rows */
</Table>

```

Source:
[Components > Containers > Table > Basic With Heading](?path=/story/components-containers-table--basic-with-heading)

## `px2rem()` Function

This is another handy utility function that will convert pixel units into relative units. While
using the [Canvas Token System](?path=/docs/guides-tokens-migration-overview--docs) is **strongly
recommended** first, this is a nice tool for using relative units if a space token isn't feasible.

Further reading: [Canvas Kit Styling Utilities](?path=/docs/styling-utilities--docs)

```
/**
* In this example, we wanted the main content region
* of the grid to have a height of 800px.
*/
const gridLayoutStyles = createStyles({
  ...
  gridTemplateRows: `auto ${px2rem(800)} auto`,
});
```

Source:
[Guides > Accessibility > Page Structure](?path=/docs/guides-accessibility-page-structure--docs)

## Responsiveness and Reflow

**WCAG v2.2 success criterion 1.4.10 Reflow states:**

> _“Content can be presented without loss of information or functionality, and without requiring
> scrolling in two dimensions for vertical scrolling content at a width equivalent to 320 CSS pixels
> and horizontal scrolling content at a height equivalent to 256 CSS pixels. ”_

Of course, there are exceptions to this guideline, including tables that do not apply. (Source:
[Understanding Success Criterion 1.4.10 Reflow](https://www.w3.org/WAI/WCAG22/Understanding/reflow.html))
In general, we have 2 key recommendations for satisfying this guideline:

1. Do not specify a minimum width greater than `320px` to avoid unnecessary horizontal scroll.
2. Do not use any sticky headers or footers at the smallest responsive breakpoints.

### How we test against this guideline:

Set the browser viewport to `1280px x 1024px` and increase browser zoom to 400%. This is
mathetmatically equivalent to a width of 320 and a height of 256 CSS pixels.

- Evaluate whether any horizontal scroll isn't necessary in the application.
- Evaluate whether there is any loss of function due to sticky content.
- Look for clipping and overlapping content.

## Supporting Windows 11 High Contrast Desktop Themes

High-contrast themes in Windows 11 are crucial for accessibility. High contrast themes overwrite CSS
colors including `color`, `backgroundColor`, and `boxShadow`, while `border` and `outline`
properties retain their settings. To ensure your UI is compatible, follow these best practices for
improved visibility.

Further reading:
[Change color contrast in Windows](https://support.microsoft.com/en-us/windows/change-color-contrast-in-windows-fedc744c-90ac-69df-aed5-c8a90125e696)

### Focus Indicators:

Since Canvas Kit components rely on `boxShadow` for the keyboard focus state, it won’t be visible in
high contrast themes. We’ve added a `2px solid transparent` CSS `outline` to ensure a focus
indicator remains visible. Use `outlineOffset` to add space between the element and the outline for
aesthetics. We’ve used a `2px` offset on components like
[BaseButton](https://github.com/Workday/canvas-kit/blob/master/modules/react/button/lib/BaseButton.tsx)
to match the visual design of the `boxShadow` in the system. A `-2px` negative offset is used for
focusable components inside popup containers like the `<Menu>` component to ensure the focus
indicator isn’t clipped off the edge. (For example:
[MenuItem](https://github.com/Workday/canvas-kit/blob/master/modules/react/menu/lib/MenuItem.tsx).)

### Boundary Borders and Outlines:

If content needs to be grouped with a boundary in high contrast themes, using a `transparent` CSS
`outline` can be useful because it won’t cause alignment problems on the page. We’ve done this to
draw boundaries in components that don't have any focus state like
[ModalCard](https://github.com/Workday/canvas-kit/blob/master/modules/react/modal/lib/ModalCard.tsx)
and
[TooltipContainer](https://github.com/Workday/canvas-kit/blob/master/modules/react/tooltip/lib/TooltipContainer.tsx).

### Images:

`<img>` elements, which are for images like JPEGs or PNGs, are not affected by high contrast themes.
If you use a meaningful image with a transparent background, it could become difficult to see
against some background colors. Be careful when using such images for conveying information to
users.

<Flex justifyContent="space-around">
  <img src={checkMark} alt="Check mark images highly visible on white background" />
  <img src={checkMarkWhcm} alt="Check mark images have poor contrast on dark background" />
</Flex>

### SVG Icons

The colors inside `<svg>` elements usually don't change with high contrast themes, which can make
them hard to see on some backgrounds. We’ve used a media query to set the icon `fill` and `color`
properties to `currentColor` ensuring the icon uses the correct color from the user's preferred high
contrast theme.

```
// for Windows high contrast desktop themes
'@media (prefers-contrast: more)': {
  '.wd-icon-fill, .wd-icon-accent': {
    color: 'currentColor',
    fill: 'currentColor',
  },
},
```

<Flex justifyContent='space-around'>
<figure margin='0'>
  <img src={iconBefore} alt="" />
  <figcaption>Before: The mail icon color has poor contrast on dark backgrounds</figcaption>
</figure>

<figure margin='0'>
  <img src={iconAfter} alt="" />
  <figcaption>After: The mail icon inherits the theme's current color for best contrast</figcaption>
</figure>
</Flex>
