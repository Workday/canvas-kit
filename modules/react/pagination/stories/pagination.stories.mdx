import {Meta} from '@storybook/addon-docs/blocks';

import {Pagination} from '@workday/canvas-kit-react/pagination';

import {Basic} from './examples/Basic';
import {CustomRange} from './examples/CustomRange';
import {JumpControls} from './examples/JumpControls';
import {GoToForm} from './examples/GoToForm';
import {ShowAdditionalDetails} from './examples/ShowAdditionalDetails';
import {HoistedModel} from './examples/HoistedModel';
import {RTL} from './examples/RTL';
import {
  PaginationModelConfigComponent,
  PaginationStateComponent,
  PaginationEventsComponent,
} from './PaginationModel.splitprops.tsx';

<Meta title="Components/Navigation/Pagination/React" component={Pagination} />

# Canvas Kit Pagination

`Pagination` is a
[compound component](/getting-started/for-developers/resources/compound-components/) for handling
navigation between pages in a range.

## Installation

```sh
yarn add @workday/canvas-kit-react
```

## Usage

### Basic Example

`Pagination` includes a container `Pagination` component and a number of subcomponents which can be
composed in a variety of ways.

In this example, we set up a basic `Pagination` component with the default range of 5 pages, as well
as step controls (`Pagination.StepToPreviousButton` and `Pagination.StepToNextButton`) that allow
you to move to the next page or the previous page.

<ExampleCodeBlock code={Basic} />

### Hoisted Model

By default, `Pagination` will create and use its own [model](#model) internally. Alternatively, you
may configure your own model with `usePaginationModel` and pass it to `Pagination` via the `model`
prop. This pattern is referred to as
[hoisting the model](/getting-started/for-developers/resources/compound-components/#configuring-a-model)
and provides direct access to its `state` and `events` outside of the `Pagination` component.

In this example, we set up external observation of the model state and create an external button to
trigger an event to change the current page.

<ExampleCodeBlock code={HoistedModel} />

### Jump Controls

This example adds jump controls (`Pagination.JumpToFirstButton` and `Pagination.JumpToLastButton`)
that allow you to skip to the first and last pages in the range.

<ExampleCodeBlock code={JumpControls} />

### GoTo Form

This example adds a form (`Pagination.GoToForm`) that allows you to skip to a specific page within
the range.

<ExampleCodeBlock code={GoToForm} />

### Additional Details

This example adds a visible section (`Pagination.AdditionalDetails`). It is an `aria-live` region
that announces the current page update to screen readers. Because of that, it's important to
**alwaysâ€ ** include it in your `Pagination` component.

In the case where you would also have multiple `Pagination` components sharing the same state and
you'd like to keep the `AdditionalDetails` component on multiple, you will need to set
`shouldAnnounceToScreenReader` to `false` on all but one component to prevent announcement.

> **â€ ** _The only exception to this rule is when you have multiple `Pagination` components that are
> sharing the same state and rendered on the page. You can then safely remove all but one of the
> `AdditionalDetails` sections. This will prevent a screenreader from announcing updates multiple
> times to a user._

<ExampleCodeBlock code={ShowAdditionalDetails} />

### Right-to-Left (RTL)

This example shows how the component supports right-to-left languages.

<ExampleCodeBlock code={RTL} />

### Custom Range

This example uses a custom range that allows you to control the width of the component.

<ExampleCodeBlock code={CustomRange} />

## Components

### Pagination

#### Usage

`Pagination` is a container component rendered with a `<nav>` element that is responsible for
creating a `PaginationModel` and sharing it with its subcomponents using React context.

```tsx
<Pagination
  aria-label="Pagination"
  lastPage={100}
  initialCurrentPage={6}
  rangeSize={3}
  onPageChange={pageNumber => console.log(pageNumber)}
>
  {/* Child components */}
</Pagination>
```

Alternatively, you may pass in a model using the hoisted model pattern. Note that in this pattern,
the only props needed are `model` and `aria-label`.

```tsx
const model = usePaginationModel({
  lastPage: 100,
  initialCurrentPage: 6,
  rangeSize: 3,
  onPageChange: pageNumber => console.log(pageNumber),
});

return (
  <Pagination aria-label="Pagination" model={model}>
    {/* Child components */}
  </Pagination>
);
```

#### Props

Undocumented props are spread to the underlying `<nav>` element.

Given that there are two ways to configure `Pagination`, there are also two props tables. For the
configuration pattern, follow this table:

| name               | type                           | required?  | default | recommended                              |
| ------------------ | ------------------------------ | ---------- | ------- | ---------------------------------------- |
| aria-label         | `string`                       | âœ… `true`  | n/a     | "Pagination" (and translated equivalent) |
| lastPage           | `number`                       | âœ… `true`  | n/a     | n/a                                      |
| initialCurrentPage | `number`                       | ðŸš« `false` | 1       | n/a                                      |
| rangeSize          | `number`                       | ðŸš« `false` | 5       | n/a                                      |
| firstPage          | `number`                       | ðŸš« `false` | 1       | n/a                                      |
| onPageChange       | `(pageNumber: number) => void` | ðŸš« `false` | n/a     | n/a                                      |

And for the hoisted model pattern, follow this table:

| name       | type              | required? | default | recommended                              |
| ---------- | ----------------- | --------- | ------- | ---------------------------------------- |
| aria-label | `string`          | âœ… `true` | n/a     | "Pagination" (and translated equivalent) |
| model      | `PaginationModel` | âœ… `true` | n/a     | n/a                                      |

This component also supports
[all native HTMLElement props](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes).
The `aria-label` prop is required for accessibility. We recommend using `"Pagination"` as seen in
the example.

### Pagination.Controls

#### Usage

`Pagination.Controls` is a styled `<div>` element that provides proper alignment and spacing between
elements inside `Pagination`. It does not handle any internal business logic or state.

```tsx
<Pagination.Controls>{/* Child components */}</Pagination.Controls>
```

#### Props

This component supports
[all native HTMLDivElement props](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div#Attributes).

### Pagination.JumpToFirstButton

#### Usage

`Pagination.JumpToFirstButton` is an `IconButton` that subscribes to `Pagination`'s context. This
allows it to know when to disable and set `currentPage` to the first page.

```tsx
<Pagination.JumpToFirstButton aria-label="First" />
```

#### Props

| name       | type     | required? | default | recommended                         |
| ---------- | -------- | --------- | ------- | ----------------------------------- |
| aria-label | `string` | âœ… `true` | n/a     | "First" (and translated equivalent) |

This component also supports all `IconButton` props.

### Pagination.StepToPreviousButton

#### Usage

`Pagination.StepToPreviousButton` is an `IconButton` that subscribes to `Pagination`'s context. This
allows it to know when to disable and decrement the `currentPage`.

```tsx
<Pagination.StepToPreviousButton aria-label="Previous" />
```

#### Props

| name       | type     | required? | default | recommended                            |
| ---------- | -------- | --------- | ------- | -------------------------------------- |
| aria-label | `string` | âœ… `true` | n/a     | "Previous" (and translated equivalent) |

This component also supports all `IconButton` props.

### Pagination.StepToNextButton

#### Usage

`Pagination.StepToNextButton` is an `IconButton` that subscribes to `Pagination`'s context. This
allows it to know when to disable and increment the `currentPage`.

```tsx
<Pagination.StepToNextButton aria-label="Next" />
```

#### Props

| name       | type     | required? | default | recommended                        |
| ---------- | -------- | --------- | ------- | ---------------------------------- |
| aria-label | `string` | âœ… `true` | n/a     | "Next" (and translated equivalent) |

This component also supports all `IconButton` props.

### Pagination.JumpToLastButton

#### Usage

`Pagination.JumpToLastButton` is an `IconButton` that subscribes to `Pagination`'s context. This
allows it to know when to disable and set `currentPage` to the last page.

```tsx
<Pagination.JumpToLastButton aria-label="Last" />
```

#### Props

| name       | type     | required? | default | recommended                        |
| ---------- | -------- | --------- | ------- | ---------------------------------- |
| aria-label | `string` | âœ… `true` | n/a     | "Last" (and translated equivalent) |

This component also supports all `IconButton` props.

### Pagination.PageList

#### Usage

`Pagination.PageList` is an ordered list (`ol`) that subscribes to `Pagination`'s context. This
allows it generate the `range` of page numbers. It also handles spacing between the child elements.
This component will accept either child elements or functional children (sometimes called the render
prop pattern). It's likely you'll want to use the functional children, but in the off-chance you
need a static list of items, this component will support it. The usage section below will provide
examples of both.

The functional children snippet below will likely be the most common use case.

```tsx
<Pagination.PageList>
  {({state}) =>
    state.range.map(pageNumber => (
      <Pagination.PageListItem key={pageNumber}>
        <Pagination.PageButton aria-label={`Page ${pageNumber}`} pageNumber={pageNumber} />
      </Pagination.PageListItem>
    ))
  }
</Pagination.PageList>
```

#### Props

| name     | type                                                             | required?  | default | recommended |
| -------- | ---------------------------------------------------------------- | ---------- | ------- | ----------- |
| children | (model: PaginationModel) => React.ReactNode[] \| React.ReactNode | ðŸš« `false` | n/a     | n/a         |

This component also supports
[all native HTMLOLElement props](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol#Attributes).

### Pagination.PageListItem

#### Usage

`Pagination.PageListItem` is a styled `li` element. It provides a child semantic element for the
`PageList` component and is important for accessibility. It does not handle any internal business
logic or state.

```tsx
<Pagination.PageListItem>{/* child element goes here */}</Pagination.PageListItem>
```

#### Props

This component also supports
[all native HTMLLIElement props](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li#Attributes).

### Pagination.PageButton

#### Usage

`Pagination.PageButton` is an `IconButton` that subscribes to `Pagination`'s context. This allows it
to know set the `toggled` styling when it is the current item and update the `currentPage`.

`PageButton` will render the `pageNumber` as its children.

```tsx
<Pagination.PageButton aria-label="Page 2" pageNumber={2} />
```

#### Props

| name       | type     | required? | default | recommended                                      |
| ---------- | -------- | --------- | ------- | ------------------------------------------------ |
| aria-label | `string` | âœ… `true` | n/a     | `Page ${pageNumber}` (and translated equivalent) |
| pageNumber | `number` | âœ… `true` | n/a     | n/a                                              |

This component also supports all `IconButton` props.

### Pagination.GoToForm

#### Usage

`Pagination.GoToForm` is a wrapper for a React context provider and `form` element. Child components
such as `Pagination.GoToTextInput` and `Pagination.GoToLabel` subscribe to that context to manage
the form state and behavior as well as update the `currentPage` in the `Pagination` component.

```tsx
<Pagination.GoToForm>{/* child elements go here */}</Pagination.GoToForm>
```

#### Props

This component supports
[all native HTMLFormElement props](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#Attributes).

### Pagination.GoToTextInput

#### Usage

```tsx
<Pagination.GoToTextInput aria-label="Go to page number" />
```

#### Props

| name       | type                 | required?  | default | recommended                                     |
| ---------- | -------------------- | ---------- | ------- | ----------------------------------------------- |
| aria-label | `string`             | âœ… `true`  | n/a     | `Go to page number` (and translated equivalent) |
| value      | `string` \| `number` | ðŸš« `false` | ""      | n/a                                             |

This component also supports all `TextInput` props.

### Pagination.GoToLabel

#### Usage

`Pagination.GoToLabel` is a styled `label` element that subscribes to the `Pagination` context. This
allows it to pass the `Pagination` context to child elements.

This component will accept either child elements or functional children (sometimes called the render
prop pattern). It's likely you'll want to use the functional children, but in the off-chance you
need static child elements, this component will support it. Examples of both patterns are provided
below.

**Functional Children**

Use this pattern when you need access to the state in the `Pagination` context for your text.

```tsx
<Pagination.GoToLabel>{({state}) => `of ${state.lastPage} results`}</Pagination.GoToLabel>
```

#### Props

| name     | type                                                           | required?  | default | recommended |
| -------- | -------------------------------------------------------------- | ---------- | ------- | ----------- |
| htmlFor  | `string`                                                       | ðŸš« `false` | n/a     | n/a         |
| children | (model: PaginationModel) => React.ReactNode \| React.ReactNode | ðŸš« `false` | n/a     | n/a         |

This component also supports
[all native HTMLLabelElement props](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label#Attributes).

### Pagination.AdditionalDetails

#### Usage

`Pagination.AdditionalDetails` is a styled `div` container that subscribes to the `Pagination`
context. This allows it to pass the `Pagination` context to child elements. It is also an
`aria-live` region that announces the current page update to screen readers. Because of that, it's
important to always\* include it in your `Pagination` component.

_\* The only exception to this rule is when you have multiple `Pagination` components that are
sharing the same state and rendered on the page. You can then safely remove all but one of the
`AdditionalDetails` sections. This will prevent a screenreader from announcing updates multiple
times to a user._

In the case where you would also have multiple `Pagination` components sharing the same state and
you'd like to keep the `AdditionalDetails` component on multiple, you will need to set
`shouldAnnounceToScreenReader` to `false` on all but one component to prevent announcement.

This component will accept either child elements or functional children (sometimes called the render
prop pattern). It's likely you'll want to use the functional children, but in the off-chance you
need static child elements, this component will support it.

```tsx
<Pagination.AdditionalDetails>
  {({state}) =>
    `${getVisibleResultsMin(state.currentPage, resultCount)}-${getVisibleResultsMax(
      state.currentPage,
      resultCount,
      totalCount
    )} of ${totalCount} results`
  }
</Pagination.AdditionalDetails>
```

#### Props

| name                         | type                                                           | required?  | default | recommended |
| ---------------------------- | -------------------------------------------------------------- | ---------- | ------- | ----------- |
| shouldHideDetails            | `boolean`                                                      | ðŸš« `false` | false   | n/a         |
| shouldAnnounceToScreenReader | `boolean`                                                      | ðŸš« `false` | true    | n/a         |
| children                     | (model: PaginationModel) => React.ReactNode \| React.ReactNode | âœ… `true`  | n/a     | n/a         |

## Model

If `Pagination` was stripped of all its markup, attributes, and styling, what would remain is the
[model](/getting-started/for-developers/resources/compound-components/#models). The model is an
object composed of two parts: `state` which describes the current snapshot in time of the component
and `events` which describes events that can be sent to the model.

By default, `Pagination` will create a model and share it internally with its subcomponents using
React context. You may subscribe to `PaginationContext` if you wish to create a custom subcomponent
for your implementation. Here's a simple example.

```tsx
import * as React from 'react';
import {Pagination, PaginationContext} from '@workday/canvas-kit-react/pagination';

const CustomButton = (props: React.HTMLAttributes<HTMLButtonElement>) => {
  const model = React.useContext(PaginationContext);

  const handleClick = (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {
    // If onClick is provided, pass the event along
    props.onClick?.(e);
    model.events.goTo(10);
  };

  return (
    <button onClick={handleClick} {...props}>
      Go To Page 10
    </button>
  );
};

export const CustomPagination = () => {
  return (
    <Pagination aria-label="Pagination" lastPage={20}>
      <CustomButton aria-label="Page 10" />
      {/* Other subcomponents */}
    </Pagination>
  );
};
```

Alternatively, if you need direct access to the model's `state` and `events` outside of the
`Pagination` component, you may configure your own model with `usePaginationModel` and pass it to
`Pagination` via a pattern called
[hoisting the model](/getting-started/for-developers/resources/compound-components/#configuring-a-model).

```tsx
const model = usePaginationModel({
  lastPage,
  onPageChange: number => console.log(number),
});

<Pagination aria-label="Pagination" model={model}>
  {/* Child components */}
</Pagination>;
```

### Config

`usePaginationModel` accepts a configuration object with the following properties and returns a
`PaginationModel` with `state` and `events` properties.

<ArgsTable of={PaginationModelConfigComponent} />

### State

The `PaginationModel` `state` is an object with the following properties.

<ArgsTable of={PaginationStateComponent} />

### Events

The `PaginationModel` `events` is an object with the following properties.

<ArgsTable of={PaginationEventsComponent} />

## Utilities

### getLastPage

This function takes the number of results per page and the total count of results and returns the
last page number. Here's an example:

Given there are 10 results per page, and there are 128 total results, the function will return 13.

```ts
const resultCount = 10;
const totalCount = 128;
const lastPage = getLastPage(resultCount, totalCount); //=> 13
```

### getRangeMin

This function takes the pagination range and returns its minimum value. Here's an example:

Given the pagination range is 1-5, the function will return 1.

```ts
const range = [1, 2, 3, 4, 5];
const rangeMin = getRangeMin(range); //=> 1
```

### getRangeMax

This function takes the pagination range and returns its maximum value. Here's an example:

Given the pagination range is 1-5, the function will return 5.

```ts
const range = [1, 2, 3, 4, 5];
const rangeMin = getRangeMax(range); //=> 5
```

### getVisibleResultsMin

This function takes the current page, and number of results per page, and returns the minimum value
for that page. Here's an example:

Given there are 10 results per page, and the current page is 5, the function will return 41.

```ts
const currentPage = 5;
const resultCount = 10;
const pageMin = getVisibleResultsMin(currentPage, resultCount); //=> 41
```

### getVisibleResultsMax

This function takes the current page, number of results per page, and the total number of results,
and returns the maximum value for that page. Here's an example:

Given there are 10 results per page, the current page is 5, and there are 42 results total, the
function will return 42.

```ts
const currentPage = 5;
const resultCount = 10;
const totalCount = 42;
const pageMax = getVisibleResultsMax(currentPage, resultCount, totalCount); //=> 42
```
