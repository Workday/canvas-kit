import {Meta} from '@storybook/addon-docs';
import {Specifications} from '@workday/canvas-kit-docs';
import {CreateModelHook} from './examples/CreateModelHook';
import {CreateContainer} from './examples/CreateContainer';
import {CreateSubcomponent} from './examples/CreateSubcomponent';
import {CreateElemPropsHook} from './examples/CreateElemPropsHook';

<Meta title="Hooks and Utilities" />

# Compound Component Utilities

The following utilities are meant to be used together to create and compose components.

## Installation

```sh
yarn add @workday/canvas-kit-react
```

# createModelHook

When building compound components that might have some internal state or events, you typically want
a model. A model allows a component to share information. This is where `createModelHook` comes in
handy.

## Usage

`createModelHook` is a factory function that takes in `defaultConfig` and `requiredConfig` and
returns a function which is your model hook.

If we take diclosure as an example, this is how we'd use `composeModelHook`

```tsx
import {createModelHook} from '@workday/canvas-kit-react/common';
export const useDisclosureModel = createModelHook({
  // This becomes the default values on the model
  defaultConfig: {
    // some default config
  },
})(config => {
  const state = {
    // some state
  };
  // Sets events that be used across sub components
  const events = {
    // some events
  };

  return {state, events};
});
```

<ExampleCodeBlock code={CreateModelHook} />

Typescript will infer all config from the returned `state`, `events`, `defaultConfig` and the
`requiredConfig`.

## API

When `useDisclosureModel`is created, 5 properties are attached to it for composability:
`defaultConfig`, `requiredConfig`, `TConfig`, `getElemProps`, `Context`.

### defaultConfig

Using this can be useful when creating other models that share similar config for example:

```tsx
import {createModelHook} from '@workday/canvas-kit-react/common';
export const useExpandableModel = createModelHook({
  defaultConfig: {
    // extend the default config from the `useDisclosureModel`
    ...useDisclosureModel.defaultConfig,
  },
})(config => {
  const disclosure = useDisclosureModel(config);
  const state = {
    ...disclosure.state,
  };
  const events = {
    ...disclosure.events,
  };
  return {state, events};
});
```

### Context

This is useful when you're using components that need to share the same context. When you use
`composeModelHook` this will create a context for you. When you're combining hooks together
sometimes you want to share the same context. A good example of this is if you're building a `Modal`
component but you created a `usePopupModel` that created the context for sub component to share.

```tsx
import {createModelHook} from '@workday/canvas-kit-react/common';
export const useModalModel = createModelHook({
  defaultConfig: usePopupModel.defaultConfig,
  requiredConfig: usePopupModel.requiredConfig,
  // share context from the usePopupModel instead of the default one created by createModelHook
  contextOverride: usePopupModel.Context,
})(config => {
  const model = usePopupModel(config);

  useInitialFocus(model);
  useReturnFocus(model);
  useCloseOnOverlayClick(model);
  useCloseOnEscape(model);
  useFocusTrap(model);
  useAssistiveHideSiblings(model);
  useDisableBodyScroll(model);

  return model;
});
```

### TConfig

TConfig gives you the typings that are defined in `defaultConfig` and `requiredConfig` instead of
having to redfine those types. This is useful when building a model that share similar config and
you want to merge them while getting the correct typings.

```tsx
import {createModelHook} from '@workday/canvas-kit-react/common';
export const useActionBarModel = createModelHook({
  defaultConfig: {
    // We define the config and use the typings that come from useMenuModel for when an action bar renders a menu
    menuConfig: {} as typeof useMenuModel.TConfig,
  },
  requiredConfig: useOverflowListModel.requiredConfig,
})(config => {
  // define your internal state and events
});
```

### getElemProps

This function will separate all `elemProps` or default attributes from an element from config props.
If a prop is both a `config` _and_ an `elemProp`, you can manually apply the prop again.

By default `createModelHook` does this for you and spread the `elemProps` onto the component.

# createContainer

When building a component that has a model, you typically start with a container component.
`createContainer` is a utility function that hooks up all the pieces for you.

## Usage

- It will wrap your component in a context provider so that `subComponents` have access to the
  model.
- It attaches your model hook to your component
- It runs any `elemPropsHook` hooks defined
- You can attach `subComponents`.
- It will also extract the element attributes and define the `ref` type based on the element you
  give it.

```tsx
import {createContainer} from '@workday/canvas-kit-react/common';
interface DisclosureProps {}

//... useDiscloseModel

export const Disclosure = createContainer('div')({
  displayName: 'Disclosure',
  modelHook: useDisclosureModel,
})<DisclosureProps>(({children, ...elemProps}, Element, model) => {
  return (
    // spread div attributes including ref
    <Element {...elemProps}>{children}</Element>
  );
});
```

<ExampleCodeBlock code={CreateContainer} />

# createSubcomponent

Once you've built a container component, adding sub component is easy. `createSubcomponent` is
similar to `createContainer` in that it hooks up a lot of the piece for you. The main difference
being that is uses the context created by `createContainer`. This allows access to the model created
at the root level so that you can use any state or events at a child component level.

## Usage

- It subscribes to the parent context allowing you access to the model hook `state` and `events`
- It attaches your model hook to your component
- It runs any `elemPropsHook` hooks defined
- You can attach `subComponents`.
- It will also extract the element attributes and define the `ref` type based on the element you
  give it.

```tsx
import {createSubcomponent} from '@workday/canvas-kit-react/common';
import {PrimaryButton} from '@workday/canvas-kit-react/button';
export interface DisclosreTargetProps {
  /**
   * The children of the `Expandable.Target`
   */
  children?: React.ReactNode;
}

//... useDiscloseModel

export const DisclosureTarget = createSubcomponent('button')({
  modelHook: useDisclosureModel,
})<DisclosreTargetProps>(({children, ...elemenProps}, Element, model) => {
  return (
    <PrimaryButton
      as={Element}
      onClick={() =>
        model.state.visibility === 'hidden' ? model.events.show() : model.events.hide()
      }
      {...elemenProps}
    >
      {children}
    </PrimaryButton>
  );
});
```

<ExampleCodeBlock code={CreateSubcomponent} />

# createElemPropsHook

This is a utility function that is helpful to use when you have elem attributes that need to be
dyanmic based on the model hook state. This function will also handle merging of element props.

Once you create your element props hook you then attach your hook to either your `createContainer`
component or `createSubcomponent` by adding it to the `elemPropsHook` property.

## Usage

```tsx
import {createSubcomponent, createElemPropsHook} from '@workday/canvas-kit-react/common';
import {Box} from '@workday/canvas-kit-react/layout';

export interface DisclosureContentProps extends BoxProps {
  /**
   * The children of the `Expandable.Content` whose visibility is controlled by the associated
   * `Expandable.Target`
   */
  children?: React.ReactNode;
}

//...useDiscloseModel defined

// Use createElemPropsHook to add style and id attribute based on the disclosure model hook state
// These attributes will be merged with the rest of elemProps that come from DisclosureContentProps
const useDisclosureContent = createElemPropsHook(useDisclosureModel)(({state}) => {
  return {
    style: state.visibility !== 'hidden' ? {} : {display: 'none'},
    id: state.id,
  };
});

export const DisclosureContent = createSubcomponent('div')({
  modelHook: useDisclosureModel,
  // attached our elemPropsHook to the component
  elemPropsHook: useDisclosureContent,
})<DisclosureContentProps>(({children, ...elementProps}, Element) => {
  return (
    <Box as={Element} {...elementProps}>
      {children}
    </Box>
  );
});
```

<ExampleCodeBlock code={CreateElemPropsHook} />
