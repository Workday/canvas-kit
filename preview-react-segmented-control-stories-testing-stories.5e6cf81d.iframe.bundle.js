"use strict";(globalThis.webpackChunkcanvas_kit=globalThis.webpackChunkcanvas_kit||[]).push([[4215],{"./modules/preview-react/segmented-control/stories/testing.stories.tsx":(module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.TextOnlyStates=exports.TextAndIconStates=exports.IconOnlyVerticalStates=exports.IconOnlyHorizontalStates=exports.default=void 0;var _react=function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}(__webpack_require__("./node_modules/react/index.js")),_testing=__webpack_require__("./modules/react/testing/index.ts"),_segmentedControl=__webpack_require__("./modules/preview-react/segmented-control/index.ts"),_canvasSystemIconsWeb=__webpack_require__("./node_modules/@workday/canvas-system-icons-web/dist/es6/index.js");function _extends(){return _extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends.apply(this,arguments)}var _default={title:"Testing/Preview/Segmented Control",component:_segmentedControl.SegmentedControl,parameters:{storySource:{source:"\n    \n    // @ts-nocheck\n    // @ts-expect-error (Converted from ts-ignore)\n    var __STORY__ = \"import React from 'react';\\nimport {\\n  ComponentStatesTable,\\n  permutateProps,\\n  StaticStates,\\n} from '@workday/canvas-kit-react/testing';\\nimport {SegmentedControl} from '@workday/canvas-kit-preview-react/segmented-control';\\nimport {gridIcon, listViewIcon, listDetailIcon} from '@workday/canvas-system-icons-web';\\n\\nexport default {\\n  title: 'Testing/Preview/Segmented Control',\\n  component: SegmentedControl,\\n  parameters: {\\n    chromatic: {\\n      disable: false,\\n    },\\n  },\\n};\\n\\nconst stateTableColumnProps = [\\n  {label: 'Default ', props: {}},\\n  {label: 'Default Disabled', props: {disabled: true}},\\n  {label: 'Hover ', props: {itemProps: {className: 'hover'}}},\\n  {label: 'Hover Disabled', props: {disabled: true, itemProps: {className: 'hover'}}},\\n  {label: 'Focus ', props: {itemProps: {className: 'focus'}}},\\n  {label: 'Focus Hover ', props: {itemProps: {className: 'focus hover'}}},\\n  {label: 'Active/Pressed', props: {itemProps: {className: 'active'}}},\\n];\\n\\nexport const IconOnlyHorizontalStates = {\\n  render: () => (\\n    <StaticStates>\\n      <ComponentStatesTable\\n        rowProps={permutateProps({\\n          size: [\\n            {value: 'small', label: 'Small'},\\n            {value: 'medium', label: 'Medium'},\\n            {value: 'large', label: 'Large'},\\n          ],\\n          initialValue: [\\n            {value: 'table', label: ' with first item selected'},\\n            {value: 'list', label: ' with second item selected'},\\n            {value: 'detail', label: ' with third item selected'},\\n          ],\\n        })}\\n        columnProps={stateTableColumnProps}\\n      >\\n        {({itemProps, ...props}) => (\\n          <SegmentedControl shouldSelect={() => false} {...props}>\\n            <SegmentedControl.List aria-label=\\\"View type\\\">\\n              <SegmentedControl.Item\\n                data-id=\\\"table\\\"\\n                icon={gridIcon}\\n                tooltipProps={{title: 'Table'}}\\n              />\\n              <SegmentedControl.Item\\n                data-id=\\\"list\\\"\\n                icon={listViewIcon}\\n                tooltipProps={{title: 'List'}}\\n                {...itemProps}\\n              />\\n              <SegmentedControl.Item\\n                data-id=\\\"detail\\\"\\n                icon={listDetailIcon}\\n                tooltipProps={{title: 'Detail'}}\\n              />\\n            </SegmentedControl.List>\\n          </SegmentedControl>\\n        )}\\n      </ComponentStatesTable>\\n    </StaticStates>\\n  ),\\n};\\n\\nexport const IconOnlyVerticalStates = {\\n  render: () => (\\n    <StaticStates>\\n      <ComponentStatesTable\\n        rowProps={permutateProps({\\n          size: [\\n            {value: 'small', label: 'Small'},\\n            {value: 'medium', label: 'Medium'},\\n            {value: 'large', label: 'Large'},\\n          ],\\n          initialValue: [\\n            {value: 'table', label: ' with first item selected'},\\n            {value: 'list', label: ' with second item selected'},\\n            {value: 'detail', label: ' with third item selected'},\\n          ],\\n        })}\\n        columnProps={stateTableColumnProps}\\n      >\\n        {({itemProps, ...props}) => (\\n          <SegmentedControl shouldSelect={() => false} orientation=\\\"vertical\\\" {...props}>\\n            <SegmentedControl.List aria-label=\\\"View type\\\">\\n              <SegmentedControl.Item\\n                data-id=\\\"table\\\"\\n                icon={gridIcon}\\n                tooltipProps={{title: 'Table'}}\\n              />\\n              <SegmentedControl.Item\\n                data-id=\\\"list\\\"\\n                icon={listViewIcon}\\n                tooltipProps={{title: 'List'}}\\n                {...itemProps}\\n              />\\n              <SegmentedControl.Item\\n                data-id=\\\"detail\\\"\\n                icon={listDetailIcon}\\n                tooltipProps={{title: 'Detail'}}\\n              />\\n            </SegmentedControl.List>\\n          </SegmentedControl>\\n        )}\\n      </ComponentStatesTable>\\n    </StaticStates>\\n  ),\\n};\\n\\nexport const TextAndIconStates = {\\n  render: () => (\\n    <StaticStates>\\n      <ComponentStatesTable\\n        rowProps={permutateProps({\\n          size: [\\n            {value: 'small', label: 'Small'},\\n            {value: 'medium', label: 'Medium'},\\n            {value: 'large', label: 'Large'},\\n          ],\\n          initialValue: [\\n            {value: 'table', label: ' with first item selected'},\\n            {value: 'list', label: ' with second item selected'},\\n            {value: 'detail', label: ' with third item selected'},\\n          ],\\n        })}\\n        columnProps={stateTableColumnProps}\\n      >\\n        {({itemProps, ...props}) => (\\n          <SegmentedControl shouldSelect={() => false} {...props}>\\n            <SegmentedControl.List aria-label=\\\"View type\\\">\\n              <SegmentedControl.Item data-id=\\\"table\\\" icon={gridIcon}>\\n                Table\\n              </SegmentedControl.Item>\\n              <SegmentedControl.Item data-id=\\\"list\\\" icon={listViewIcon} {...itemProps}>\\n                List\\n              </SegmentedControl.Item>\\n              <SegmentedControl.Item data-id=\\\"detail\\\" icon={listDetailIcon}>\\n                Detail\\n              </SegmentedControl.Item>\\n            </SegmentedControl.List>\\n          </SegmentedControl>\\n        )}\\n      </ComponentStatesTable>\\n    </StaticStates>\\n  ),\\n};\\n\\nexport const TextOnlyStates = {\\n  render: () => (\\n    <StaticStates>\\n      <ComponentStatesTable\\n        rowProps={permutateProps({\\n          size: [\\n            {value: 'small', label: 'Small'},\\n            {value: 'medium', label: 'Medium'},\\n            {value: 'large', label: 'Large'},\\n          ],\\n          initialValue: [\\n            {value: 'table', label: ' with first item selected'},\\n            {value: 'list', label: ' with second item selected'},\\n            {value: 'detail', label: ' with third item selected'},\\n          ],\\n        })}\\n        columnProps={stateTableColumnProps}\\n      >\\n        {({itemProps, ...props}) => (\\n          <SegmentedControl shouldSelect={() => false} {...props}>\\n            <SegmentedControl.List aria-label=\\\"View type\\\">\\n              <SegmentedControl.Item data-id=\\\"table\\\">Table</SegmentedControl.Item>\\n              <SegmentedControl.Item data-id=\\\"list\\\" {...itemProps}>\\n                List\\n              </SegmentedControl.Item>\\n              <SegmentedControl.Item data-id=\\\"detail\\\">Detail</SegmentedControl.Item>\\n            </SegmentedControl.List>\\n          </SegmentedControl>\\n        )}\\n      </ComponentStatesTable>\\n    </StaticStates>\\n  ),\\n};\\n\";\n    // @ts-expect-error (Converted from ts-ignore)\n    var __LOCATIONS_MAP__ = {\n  \"IconOnlyHorizontalStates\": {\n    \"startLoc\": {\n      \"col\": 40,\n      \"line\": 30\n    },\n    \"endLoc\": {\n      \"col\": 1,\n      \"line\": 73\n    },\n    \"startBody\": {\n      \"col\": 40,\n      \"line\": 30\n    },\n    \"endBody\": {\n      \"col\": 1,\n      \"line\": 73\n    }\n  },\n  \"IconOnlyVerticalStates\": {\n    \"startLoc\": {\n      \"col\": 38,\n      \"line\": 75\n    },\n    \"endLoc\": {\n      \"col\": 1,\n      \"line\": 118\n    },\n    \"startBody\": {\n      \"col\": 38,\n      \"line\": 75\n    },\n    \"endBody\": {\n      \"col\": 1,\n      \"line\": 118\n    }\n  },\n  \"TextAndIconStates\": {\n    \"startLoc\": {\n      \"col\": 33,\n      \"line\": 120\n    },\n    \"endLoc\": {\n      \"col\": 1,\n      \"line\": 156\n    },\n    \"startBody\": {\n      \"col\": 33,\n      \"line\": 120\n    },\n    \"endBody\": {\n      \"col\": 1,\n      \"line\": 156\n    }\n  },\n  \"TextOnlyStates\": {\n    \"startLoc\": {\n      \"col\": 30,\n      \"line\": 158\n    },\n    \"endLoc\": {\n      \"col\": 1,\n      \"line\": 190\n    },\n    \"startBody\": {\n      \"col\": 30,\n      \"line\": 158\n    },\n    \"endBody\": {\n      \"col\": 1,\n      \"line\": 190\n    }\n  }\n};\n    \nimport React from 'react';\nimport {\n  ComponentStatesTable,\n  permutateProps,\n  StaticStates,\n} from '@workday/canvas-kit-react/testing';\nimport {SegmentedControl} from '@workday/canvas-kit-preview-react/segmented-control';\nimport {gridIcon, listViewIcon, listDetailIcon} from '@workday/canvas-system-icons-web';\n\nexport default {\n  title: 'Testing/Preview/Segmented Control',\n  component: SegmentedControl,\n  parameters: {\n  \"storySource\": {\n    \"source\": \"import React from 'react';\\nimport {\\n  ComponentStatesTable,\\n  permutateProps,\\n  StaticStates,\\n} from '@workday/canvas-kit-react/testing';\\nimport {SegmentedControl} from '@workday/canvas-kit-preview-react/segmented-control';\\nimport {gridIcon, listViewIcon, listDetailIcon} from '@workday/canvas-system-icons-web';\\n\\nexport default {\\n  title: 'Testing/Preview/Segmented Control',\\n  component: SegmentedControl,\\n  parameters: {\\n    chromatic: {\\n      disable: false,\\n    },\\n  },\\n};\\n\\nconst stateTableColumnProps = [\\n  {label: 'Default ', props: {}},\\n  {label: 'Default Disabled', props: {disabled: true}},\\n  {label: 'Hover ', props: {itemProps: {className: 'hover'}}},\\n  {label: 'Hover Disabled', props: {disabled: true, itemProps: {className: 'hover'}}},\\n  {label: 'Focus ', props: {itemProps: {className: 'focus'}}},\\n  {label: 'Focus Hover ', props: {itemProps: {className: 'focus hover'}}},\\n  {label: 'Active/Pressed', props: {itemProps: {className: 'active'}}},\\n];\\n\\nexport const IconOnlyHorizontalStates = {\\n  render: () => (\\n    <StaticStates>\\n      <ComponentStatesTable\\n        rowProps={permutateProps({\\n          size: [\\n            {value: 'small', label: 'Small'},\\n            {value: 'medium', label: 'Medium'},\\n            {value: 'large', label: 'Large'},\\n          ],\\n          initialValue: [\\n            {value: 'table', label: ' with first item selected'},\\n            {value: 'list', label: ' with second item selected'},\\n            {value: 'detail', label: ' with third item selected'},\\n          ],\\n        })}\\n        columnProps={stateTableColumnProps}\\n      >\\n        {({itemProps, ...props}) => (\\n          <SegmentedControl shouldSelect={() => false} {...props}>\\n            <SegmentedControl.List aria-label=\\\"View type\\\">\\n              <SegmentedControl.Item\\n                data-id=\\\"table\\\"\\n                icon={gridIcon}\\n                tooltipProps={{title: 'Table'}}\\n              />\\n              <SegmentedControl.Item\\n                data-id=\\\"list\\\"\\n                icon={listViewIcon}\\n                tooltipProps={{title: 'List'}}\\n                {...itemProps}\\n              />\\n              <SegmentedControl.Item\\n                data-id=\\\"detail\\\"\\n                icon={listDetailIcon}\\n                tooltipProps={{title: 'Detail'}}\\n              />\\n            </SegmentedControl.List>\\n          </SegmentedControl>\\n        )}\\n      </ComponentStatesTable>\\n    </StaticStates>\\n  ),\\n};\\n\\nexport const IconOnlyVerticalStates = {\\n  render: () => (\\n    <StaticStates>\\n      <ComponentStatesTable\\n        rowProps={permutateProps({\\n          size: [\\n            {value: 'small', label: 'Small'},\\n            {value: 'medium', label: 'Medium'},\\n            {value: 'large', label: 'Large'},\\n          ],\\n          initialValue: [\\n            {value: 'table', label: ' with first item selected'},\\n            {value: 'list', label: ' with second item selected'},\\n            {value: 'detail', label: ' with third item selected'},\\n          ],\\n        })}\\n        columnProps={stateTableColumnProps}\\n      >\\n        {({itemProps, ...props}) => (\\n          <SegmentedControl shouldSelect={() => false} orientation=\\\"vertical\\\" {...props}>\\n            <SegmentedControl.List aria-label=\\\"View type\\\">\\n              <SegmentedControl.Item\\n                data-id=\\\"table\\\"\\n                icon={gridIcon}\\n                tooltipProps={{title: 'Table'}}\\n              />\\n              <SegmentedControl.Item\\n                data-id=\\\"list\\\"\\n                icon={listViewIcon}\\n                tooltipProps={{title: 'List'}}\\n                {...itemProps}\\n              />\\n              <SegmentedControl.Item\\n                data-id=\\\"detail\\\"\\n                icon={listDetailIcon}\\n                tooltipProps={{title: 'Detail'}}\\n              />\\n            </SegmentedControl.List>\\n          </SegmentedControl>\\n        )}\\n      </ComponentStatesTable>\\n    </StaticStates>\\n  ),\\n};\\n\\nexport const TextAndIconStates = {\\n  render: () => (\\n    <StaticStates>\\n      <ComponentStatesTable\\n        rowProps={permutateProps({\\n          size: [\\n            {value: 'small', label: 'Small'},\\n            {value: 'medium', label: 'Medium'},\\n            {value: 'large', label: 'Large'},\\n          ],\\n          initialValue: [\\n            {value: 'table', label: ' with first item selected'},\\n            {value: 'list', label: ' with second item selected'},\\n            {value: 'detail', label: ' with third item selected'},\\n          ],\\n        })}\\n        columnProps={stateTableColumnProps}\\n      >\\n        {({itemProps, ...props}) => (\\n          <SegmentedControl shouldSelect={() => false} {...props}>\\n            <SegmentedControl.List aria-label=\\\"View type\\\">\\n              <SegmentedControl.Item data-id=\\\"table\\\" icon={gridIcon}>\\n                Table\\n              </SegmentedControl.Item>\\n              <SegmentedControl.Item data-id=\\\"list\\\" icon={listViewIcon} {...itemProps}>\\n                List\\n              </SegmentedControl.Item>\\n              <SegmentedControl.Item data-id=\\\"detail\\\" icon={listDetailIcon}>\\n                Detail\\n              </SegmentedControl.Item>\\n            </SegmentedControl.List>\\n          </SegmentedControl>\\n        )}\\n      </ComponentStatesTable>\\n    </StaticStates>\\n  ),\\n};\\n\\nexport const TextOnlyStates = {\\n  render: () => (\\n    <StaticStates>\\n      <ComponentStatesTable\\n        rowProps={permutateProps({\\n          size: [\\n            {value: 'small', label: 'Small'},\\n            {value: 'medium', label: 'Medium'},\\n            {value: 'large', label: 'Large'},\\n          ],\\n          initialValue: [\\n            {value: 'table', label: ' with first item selected'},\\n            {value: 'list', label: ' with second item selected'},\\n            {value: 'detail', label: ' with third item selected'},\\n          ],\\n        })}\\n        columnProps={stateTableColumnProps}\\n      >\\n        {({itemProps, ...props}) => (\\n          <SegmentedControl shouldSelect={() => false} {...props}>\\n            <SegmentedControl.List aria-label=\\\"View type\\\">\\n              <SegmentedControl.Item data-id=\\\"table\\\">Table</SegmentedControl.Item>\\n              <SegmentedControl.Item data-id=\\\"list\\\" {...itemProps}>\\n                List\\n              </SegmentedControl.Item>\\n              <SegmentedControl.Item data-id=\\\"detail\\\">Detail</SegmentedControl.Item>\\n            </SegmentedControl.List>\\n          </SegmentedControl>\\n        )}\\n      </ComponentStatesTable>\\n    </StaticStates>\\n  ),\\n};\\n\",\n    \"locationsMap\": {\n      \"icon-only-horizontal-states\": {\n        \"startLoc\": {\n          \"col\": 40,\n          \"line\": 30\n        },\n        \"endLoc\": {\n          \"col\": 1,\n          \"line\": 73\n        },\n        \"startBody\": {\n          \"col\": 40,\n          \"line\": 30\n        },\n        \"endBody\": {\n          \"col\": 1,\n          \"line\": 73\n        }\n      },\n      \"icon-only-vertical-states\": {\n        \"startLoc\": {\n          \"col\": 38,\n          \"line\": 75\n        },\n        \"endLoc\": {\n          \"col\": 1,\n          \"line\": 118\n        },\n        \"startBody\": {\n          \"col\": 38,\n          \"line\": 75\n        },\n        \"endBody\": {\n          \"col\": 1,\n          \"line\": 118\n        }\n      },\n      \"text-and-icon-states\": {\n        \"startLoc\": {\n          \"col\": 33,\n          \"line\": 120\n        },\n        \"endLoc\": {\n          \"col\": 1,\n          \"line\": 156\n        },\n        \"startBody\": {\n          \"col\": 33,\n          \"line\": 120\n        },\n        \"endBody\": {\n          \"col\": 1,\n          \"line\": 156\n        }\n      },\n      \"text-only-states\": {\n        \"startLoc\": {\n          \"col\": 30,\n          \"line\": 158\n        },\n        \"endLoc\": {\n          \"col\": 1,\n          \"line\": 190\n        },\n        \"startBody\": {\n          \"col\": 30,\n          \"line\": 158\n        },\n        \"endBody\": {\n          \"col\": 1,\n          \"line\": 190\n        }\n      }\n    }\n  }\n,\n    chromatic: {\n      disable: false,\n    },\n  },\n};\n\nconst stateTableColumnProps = [\n  {label: 'Default ', props: {}},\n  {label: 'Default Disabled', props: {disabled: true}},\n  {label: 'Hover ', props: {itemProps: {className: 'hover'}}},\n  {label: 'Hover Disabled', props: {disabled: true, itemProps: {className: 'hover'}}},\n  {label: 'Focus ', props: {itemProps: {className: 'focus'}}},\n  {label: 'Focus Hover ', props: {itemProps: {className: 'focus hover'}}},\n  {label: 'Active/Pressed', props: {itemProps: {className: 'active'}}},\n];\n\nexport const IconOnlyHorizontalStates = {\n  render: () => (\n    <StaticStates>\n      <ComponentStatesTable\n        rowProps={permutateProps({\n          size: [\n            {value: 'small', label: 'Small'},\n            {value: 'medium', label: 'Medium'},\n            {value: 'large', label: 'Large'},\n          ],\n          initialValue: [\n            {value: 'table', label: ' with first item selected'},\n            {value: 'list', label: ' with second item selected'},\n            {value: 'detail', label: ' with third item selected'},\n          ],\n        })}\n        columnProps={stateTableColumnProps}\n      >\n        {({itemProps, ...props}) => (\n          <SegmentedControl shouldSelect={() => false} {...props}>\n            <SegmentedControl.List aria-label=\"View type\">\n              <SegmentedControl.Item\n                data-id=\"table\"\n                icon={gridIcon}\n                tooltipProps={{title: 'Table'}}\n              />\n              <SegmentedControl.Item\n                data-id=\"list\"\n                icon={listViewIcon}\n                tooltipProps={{title: 'List'}}\n                {...itemProps}\n              />\n              <SegmentedControl.Item\n                data-id=\"detail\"\n                icon={listDetailIcon}\n                tooltipProps={{title: 'Detail'}}\n              />\n            </SegmentedControl.List>\n          </SegmentedControl>\n        )}\n      </ComponentStatesTable>\n    </StaticStates>\n  ),\n};;\n\nexport const IconOnlyVerticalStates = {\n  render: () => (\n    <StaticStates>\n      <ComponentStatesTable\n        rowProps={permutateProps({\n          size: [\n            {value: 'small', label: 'Small'},\n            {value: 'medium', label: 'Medium'},\n            {value: 'large', label: 'Large'},\n          ],\n          initialValue: [\n            {value: 'table', label: ' with first item selected'},\n            {value: 'list', label: ' with second item selected'},\n            {value: 'detail', label: ' with third item selected'},\n          ],\n        })}\n        columnProps={stateTableColumnProps}\n      >\n        {({itemProps, ...props}) => (\n          <SegmentedControl shouldSelect={() => false} orientation=\"vertical\" {...props}>\n            <SegmentedControl.List aria-label=\"View type\">\n              <SegmentedControl.Item\n                data-id=\"table\"\n                icon={gridIcon}\n                tooltipProps={{title: 'Table'}}\n              />\n              <SegmentedControl.Item\n                data-id=\"list\"\n                icon={listViewIcon}\n                tooltipProps={{title: 'List'}}\n                {...itemProps}\n              />\n              <SegmentedControl.Item\n                data-id=\"detail\"\n                icon={listDetailIcon}\n                tooltipProps={{title: 'Detail'}}\n              />\n            </SegmentedControl.List>\n          </SegmentedControl>\n        )}\n      </ComponentStatesTable>\n    </StaticStates>\n  ),\n};;\n\nexport const TextAndIconStates = {\n  render: () => (\n    <StaticStates>\n      <ComponentStatesTable\n        rowProps={permutateProps({\n          size: [\n            {value: 'small', label: 'Small'},\n            {value: 'medium', label: 'Medium'},\n            {value: 'large', label: 'Large'},\n          ],\n          initialValue: [\n            {value: 'table', label: ' with first item selected'},\n            {value: 'list', label: ' with second item selected'},\n            {value: 'detail', label: ' with third item selected'},\n          ],\n        })}\n        columnProps={stateTableColumnProps}\n      >\n        {({itemProps, ...props}) => (\n          <SegmentedControl shouldSelect={() => false} {...props}>\n            <SegmentedControl.List aria-label=\"View type\">\n              <SegmentedControl.Item data-id=\"table\" icon={gridIcon}>\n                Table\n              </SegmentedControl.Item>\n              <SegmentedControl.Item data-id=\"list\" icon={listViewIcon} {...itemProps}>\n                List\n              </SegmentedControl.Item>\n              <SegmentedControl.Item data-id=\"detail\" icon={listDetailIcon}>\n                Detail\n              </SegmentedControl.Item>\n            </SegmentedControl.List>\n          </SegmentedControl>\n        )}\n      </ComponentStatesTable>\n    </StaticStates>\n  ),\n};;\n\nexport const TextOnlyStates = {\n  render: () => (\n    <StaticStates>\n      <ComponentStatesTable\n        rowProps={permutateProps({\n          size: [\n            {value: 'small', label: 'Small'},\n            {value: 'medium', label: 'Medium'},\n            {value: 'large', label: 'Large'},\n          ],\n          initialValue: [\n            {value: 'table', label: ' with first item selected'},\n            {value: 'list', label: ' with second item selected'},\n            {value: 'detail', label: ' with third item selected'},\n          ],\n        })}\n        columnProps={stateTableColumnProps}\n      >\n        {({itemProps, ...props}) => (\n          <SegmentedControl shouldSelect={() => false} {...props}>\n            <SegmentedControl.List aria-label=\"View type\">\n              <SegmentedControl.Item data-id=\"table\">Table</SegmentedControl.Item>\n              <SegmentedControl.Item data-id=\"list\" {...itemProps}>\n                List\n              </SegmentedControl.Item>\n              <SegmentedControl.Item data-id=\"detail\">Detail</SegmentedControl.Item>\n            </SegmentedControl.List>\n          </SegmentedControl>\n        )}\n      </ComponentStatesTable>\n    </StaticStates>\n  ),\n};\n",locationsMap:{"icon-only-horizontal-states":{startLoc:{col:40,line:189},endLoc:{col:1,line:232},startBody:{col:40,line:189},endBody:{col:1,line:232}},"icon-only-vertical-states":{startLoc:{col:38,line:234},endLoc:{col:1,line:277},startBody:{col:38,line:234},endBody:{col:1,line:277}},"text-and-icon-states":{startLoc:{col:33,line:279},endLoc:{col:1,line:315},startBody:{col:33,line:279},endBody:{col:1,line:315}},"text-only-states":{startLoc:{col:30,line:317},endLoc:{col:1,line:349},startBody:{col:30,line:317},endBody:{col:1,line:349}}}},storySource:{source:"import React from 'react';\nimport {\n  ComponentStatesTable,\n  permutateProps,\n  StaticStates,\n} from '@workday/canvas-kit-react/testing';\nimport {SegmentedControl} from '@workday/canvas-kit-preview-react/segmented-control';\nimport {gridIcon, listViewIcon, listDetailIcon} from '@workday/canvas-system-icons-web';\n\nexport default {\n  title: 'Testing/Preview/Segmented Control',\n  component: SegmentedControl,\n  parameters: {\n    chromatic: {\n      disable: false,\n    },\n  },\n};\n\nconst stateTableColumnProps = [\n  {label: 'Default ', props: {}},\n  {label: 'Default Disabled', props: {disabled: true}},\n  {label: 'Hover ', props: {itemProps: {className: 'hover'}}},\n  {label: 'Hover Disabled', props: {disabled: true, itemProps: {className: 'hover'}}},\n  {label: 'Focus ', props: {itemProps: {className: 'focus'}}},\n  {label: 'Focus Hover ', props: {itemProps: {className: 'focus hover'}}},\n  {label: 'Active/Pressed', props: {itemProps: {className: 'active'}}},\n];\n\nexport const IconOnlyHorizontalStates = {\n  render: () => (\n    <StaticStates>\n      <ComponentStatesTable\n        rowProps={permutateProps({\n          size: [\n            {value: 'small', label: 'Small'},\n            {value: 'medium', label: 'Medium'},\n            {value: 'large', label: 'Large'},\n          ],\n          initialValue: [\n            {value: 'table', label: ' with first item selected'},\n            {value: 'list', label: ' with second item selected'},\n            {value: 'detail', label: ' with third item selected'},\n          ],\n        })}\n        columnProps={stateTableColumnProps}\n      >\n        {({itemProps, ...props}) => (\n          <SegmentedControl shouldSelect={() => false} {...props}>\n            <SegmentedControl.List aria-label=\"View type\">\n              <SegmentedControl.Item\n                data-id=\"table\"\n                icon={gridIcon}\n                tooltipProps={{title: 'Table'}}\n              />\n              <SegmentedControl.Item\n                data-id=\"list\"\n                icon={listViewIcon}\n                tooltipProps={{title: 'List'}}\n                {...itemProps}\n              />\n              <SegmentedControl.Item\n                data-id=\"detail\"\n                icon={listDetailIcon}\n                tooltipProps={{title: 'Detail'}}\n              />\n            </SegmentedControl.List>\n          </SegmentedControl>\n        )}\n      </ComponentStatesTable>\n    </StaticStates>\n  ),\n};\n\nexport const IconOnlyVerticalStates = {\n  render: () => (\n    <StaticStates>\n      <ComponentStatesTable\n        rowProps={permutateProps({\n          size: [\n            {value: 'small', label: 'Small'},\n            {value: 'medium', label: 'Medium'},\n            {value: 'large', label: 'Large'},\n          ],\n          initialValue: [\n            {value: 'table', label: ' with first item selected'},\n            {value: 'list', label: ' with second item selected'},\n            {value: 'detail', label: ' with third item selected'},\n          ],\n        })}\n        columnProps={stateTableColumnProps}\n      >\n        {({itemProps, ...props}) => (\n          <SegmentedControl shouldSelect={() => false} orientation=\"vertical\" {...props}>\n            <SegmentedControl.List aria-label=\"View type\">\n              <SegmentedControl.Item\n                data-id=\"table\"\n                icon={gridIcon}\n                tooltipProps={{title: 'Table'}}\n              />\n              <SegmentedControl.Item\n                data-id=\"list\"\n                icon={listViewIcon}\n                tooltipProps={{title: 'List'}}\n                {...itemProps}\n              />\n              <SegmentedControl.Item\n                data-id=\"detail\"\n                icon={listDetailIcon}\n                tooltipProps={{title: 'Detail'}}\n              />\n            </SegmentedControl.List>\n          </SegmentedControl>\n        )}\n      </ComponentStatesTable>\n    </StaticStates>\n  ),\n};\n\nexport const TextAndIconStates = {\n  render: () => (\n    <StaticStates>\n      <ComponentStatesTable\n        rowProps={permutateProps({\n          size: [\n            {value: 'small', label: 'Small'},\n            {value: 'medium', label: 'Medium'},\n            {value: 'large', label: 'Large'},\n          ],\n          initialValue: [\n            {value: 'table', label: ' with first item selected'},\n            {value: 'list', label: ' with second item selected'},\n            {value: 'detail', label: ' with third item selected'},\n          ],\n        })}\n        columnProps={stateTableColumnProps}\n      >\n        {({itemProps, ...props}) => (\n          <SegmentedControl shouldSelect={() => false} {...props}>\n            <SegmentedControl.List aria-label=\"View type\">\n              <SegmentedControl.Item data-id=\"table\" icon={gridIcon}>\n                Table\n              </SegmentedControl.Item>\n              <SegmentedControl.Item data-id=\"list\" icon={listViewIcon} {...itemProps}>\n                List\n              </SegmentedControl.Item>\n              <SegmentedControl.Item data-id=\"detail\" icon={listDetailIcon}>\n                Detail\n              </SegmentedControl.Item>\n            </SegmentedControl.List>\n          </SegmentedControl>\n        )}\n      </ComponentStatesTable>\n    </StaticStates>\n  ),\n};\n\nexport const TextOnlyStates = {\n  render: () => (\n    <StaticStates>\n      <ComponentStatesTable\n        rowProps={permutateProps({\n          size: [\n            {value: 'small', label: 'Small'},\n            {value: 'medium', label: 'Medium'},\n            {value: 'large', label: 'Large'},\n          ],\n          initialValue: [\n            {value: 'table', label: ' with first item selected'},\n            {value: 'list', label: ' with second item selected'},\n            {value: 'detail', label: ' with third item selected'},\n          ],\n        })}\n        columnProps={stateTableColumnProps}\n      >\n        {({itemProps, ...props}) => (\n          <SegmentedControl shouldSelect={() => false} {...props}>\n            <SegmentedControl.List aria-label=\"View type\">\n              <SegmentedControl.Item data-id=\"table\">Table</SegmentedControl.Item>\n              <SegmentedControl.Item data-id=\"list\" {...itemProps}>\n                List\n              </SegmentedControl.Item>\n              <SegmentedControl.Item data-id=\"detail\">Detail</SegmentedControl.Item>\n            </SegmentedControl.List>\n          </SegmentedControl>\n        )}\n      </ComponentStatesTable>\n    </StaticStates>\n  ),\n};\n",locationsMap:{"icon-only-horizontal-states":{startLoc:{col:40,line:30},endLoc:{col:1,line:73},startBody:{col:40,line:30},endBody:{col:1,line:73}},"icon-only-vertical-states":{startLoc:{col:38,line:75},endLoc:{col:1,line:118},startBody:{col:38,line:75},endBody:{col:1,line:118}},"text-and-icon-states":{startLoc:{col:33,line:120},endLoc:{col:1,line:156},startBody:{col:33,line:120},endBody:{col:1,line:156}},"text-only-states":{startLoc:{col:30,line:158},endLoc:{col:1,line:190},startBody:{col:30,line:158},endBody:{col:1,line:190}}}},chromatic:{disable:!1}}};exports.default=_default;const stateTableColumnProps=[{label:"Default ",props:{}},{label:"Default Disabled",props:{disabled:!0}},{label:"Hover ",props:{itemProps:{className:"hover"}}},{label:"Hover Disabled",props:{disabled:!0,itemProps:{className:"hover"}}},{label:"Focus ",props:{itemProps:{className:"focus"}}},{label:"Focus Hover ",props:{itemProps:{className:"focus hover"}}},{label:"Active/Pressed",props:{itemProps:{className:"active"}}}],IconOnlyHorizontalStates={render:()=>_react.default.createElement(_testing.StaticStates,null,_react.default.createElement(_testing.ComponentStatesTable,{rowProps:(0,_testing.permutateProps)({size:[{value:"small",label:"Small"},{value:"medium",label:"Medium"},{value:"large",label:"Large"}],initialValue:[{value:"table",label:" with first item selected"},{value:"list",label:" with second item selected"},{value:"detail",label:" with third item selected"}]}),columnProps:stateTableColumnProps},(({itemProps,...props})=>_react.default.createElement(_segmentedControl.SegmentedControl,_extends({shouldSelect:()=>!1},props),_react.default.createElement(_segmentedControl.SegmentedControl.List,{"aria-label":"View type"},_react.default.createElement(_segmentedControl.SegmentedControl.Item,{"data-id":"table",icon:_canvasSystemIconsWeb.gridIcon,tooltipProps:{title:"Table"}}),_react.default.createElement(_segmentedControl.SegmentedControl.Item,_extends({"data-id":"list",icon:_canvasSystemIconsWeb.listViewIcon,tooltipProps:{title:"List"}},itemProps)),_react.default.createElement(_segmentedControl.SegmentedControl.Item,{"data-id":"detail",icon:_canvasSystemIconsWeb.listDetailIcon,tooltipProps:{title:"Detail"}}))))))};exports.IconOnlyHorizontalStates=IconOnlyHorizontalStates;const IconOnlyVerticalStates={render:()=>_react.default.createElement(_testing.StaticStates,null,_react.default.createElement(_testing.ComponentStatesTable,{rowProps:(0,_testing.permutateProps)({size:[{value:"small",label:"Small"},{value:"medium",label:"Medium"},{value:"large",label:"Large"}],initialValue:[{value:"table",label:" with first item selected"},{value:"list",label:" with second item selected"},{value:"detail",label:" with third item selected"}]}),columnProps:stateTableColumnProps},(({itemProps,...props})=>_react.default.createElement(_segmentedControl.SegmentedControl,_extends({shouldSelect:()=>!1,orientation:"vertical"},props),_react.default.createElement(_segmentedControl.SegmentedControl.List,{"aria-label":"View type"},_react.default.createElement(_segmentedControl.SegmentedControl.Item,{"data-id":"table",icon:_canvasSystemIconsWeb.gridIcon,tooltipProps:{title:"Table"}}),_react.default.createElement(_segmentedControl.SegmentedControl.Item,_extends({"data-id":"list",icon:_canvasSystemIconsWeb.listViewIcon,tooltipProps:{title:"List"}},itemProps)),_react.default.createElement(_segmentedControl.SegmentedControl.Item,{"data-id":"detail",icon:_canvasSystemIconsWeb.listDetailIcon,tooltipProps:{title:"Detail"}}))))))};exports.IconOnlyVerticalStates=IconOnlyVerticalStates;const TextAndIconStates={render:()=>_react.default.createElement(_testing.StaticStates,null,_react.default.createElement(_testing.ComponentStatesTable,{rowProps:(0,_testing.permutateProps)({size:[{value:"small",label:"Small"},{value:"medium",label:"Medium"},{value:"large",label:"Large"}],initialValue:[{value:"table",label:" with first item selected"},{value:"list",label:" with second item selected"},{value:"detail",label:" with third item selected"}]}),columnProps:stateTableColumnProps},(({itemProps,...props})=>_react.default.createElement(_segmentedControl.SegmentedControl,_extends({shouldSelect:()=>!1},props),_react.default.createElement(_segmentedControl.SegmentedControl.List,{"aria-label":"View type"},_react.default.createElement(_segmentedControl.SegmentedControl.Item,{"data-id":"table",icon:_canvasSystemIconsWeb.gridIcon},"Table"),_react.default.createElement(_segmentedControl.SegmentedControl.Item,_extends({"data-id":"list",icon:_canvasSystemIconsWeb.listViewIcon},itemProps),"List"),_react.default.createElement(_segmentedControl.SegmentedControl.Item,{"data-id":"detail",icon:_canvasSystemIconsWeb.listDetailIcon},"Detail"))))))};exports.TextAndIconStates=TextAndIconStates;const TextOnlyStates={render:()=>_react.default.createElement(_testing.StaticStates,null,_react.default.createElement(_testing.ComponentStatesTable,{rowProps:(0,_testing.permutateProps)({size:[{value:"small",label:"Small"},{value:"medium",label:"Medium"},{value:"large",label:"Large"}],initialValue:[{value:"table",label:" with first item selected"},{value:"list",label:" with second item selected"},{value:"detail",label:" with third item selected"}]}),columnProps:stateTableColumnProps},(({itemProps,...props})=>_react.default.createElement(_segmentedControl.SegmentedControl,_extends({shouldSelect:()=>!1},props),_react.default.createElement(_segmentedControl.SegmentedControl.List,{"aria-label":"View type"},_react.default.createElement(_segmentedControl.SegmentedControl.Item,{"data-id":"table"},"Table"),_react.default.createElement(_segmentedControl.SegmentedControl.Item,_extends({"data-id":"list"},itemProps),"List"),_react.default.createElement(_segmentedControl.SegmentedControl.Item,{"data-id":"detail"},"Detail"))))))};exports.TextOnlyStates=TextOnlyStates,module.exports.__namedExportsOrder=["TextOnlyStates","TextAndIconStates","IconOnlyVerticalStates","IconOnlyHorizontalStates"]},"./node_modules/react-innertext/index.js":module=>{var reduceJsxToString=function(previous,current){return previous+innerText(current)},innerText=function(jsx){return null===jsx||"boolean"==typeof jsx||void 0===jsx?"":"number"==typeof jsx?jsx.toString():"string"==typeof jsx?jsx:Array.isArray(jsx)?jsx.reduce(reduceJsxToString,""):function(jsx){return Object.prototype.hasOwnProperty.call(jsx,"props")}(jsx)&&Object.prototype.hasOwnProperty.call(jsx.props,"children")?innerText(jsx.props.children):""};innerText.default=innerText,module.exports=innerText},"./node_modules/react-virtual/dist/react-virtual.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{defaultRangeExtractor:()=>defaultRangeExtractor,useVirtual:()=>useVirtual});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js");function _extends(){return _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends.apply(this,arguments)}var rafId,props=["bottom","height","left","right","top","width"],observedNodes=new Map,run=function run(){var changedStates=[];observedNodes.forEach((function(state,node){var newRect=node.getBoundingClientRect();(function rectChanged(a,b){return void 0===a&&(a={}),void 0===b&&(b={}),props.some((function(prop){return a[prop]!==b[prop]}))})(newRect,state.rect)&&(state.rect=newRect,changedStates.push(state))})),changedStates.forEach((function(state){state.callbacks.forEach((function(cb){return cb(state.rect)}))})),rafId=window.requestAnimationFrame(run)};var useIsomorphicLayoutEffect="undefined"!=typeof window?react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect:react__WEBPACK_IMPORTED_MODULE_0__.useEffect;function useRect(nodeRef,initialRect){void 0===initialRect&&(initialRect={width:0,height:0});var _React$useState=react__WEBPACK_IMPORTED_MODULE_0__.useState(nodeRef.current),element=_React$useState[0],setElement=_React$useState[1],_React$useReducer=react__WEBPACK_IMPORTED_MODULE_0__.useReducer(rectReducer,initialRect),rect=_React$useReducer[0],dispatch=_React$useReducer[1],initialRectSet=react__WEBPACK_IMPORTED_MODULE_0__.useRef(!1);return useIsomorphicLayoutEffect((function(){nodeRef.current!==element&&setElement(nodeRef.current)})),useIsomorphicLayoutEffect((function(){if(element&&!initialRectSet.current){initialRectSet.current=!0;var _rect=element.getBoundingClientRect();dispatch({rect:_rect})}}),[element]),react__WEBPACK_IMPORTED_MODULE_0__.useEffect((function(){if(element){var observer=function observeRect(node,cb){return{observe:function observe(){var wasEmpty=0===observedNodes.size;observedNodes.has(node)?observedNodes.get(node).callbacks.push(cb):observedNodes.set(node,{rect:void 0,hasRectChanged:!1,callbacks:[cb]}),wasEmpty&&run()},unobserve:function unobserve(){var state=observedNodes.get(node);if(state){var index=state.callbacks.indexOf(cb);index>=0&&state.callbacks.splice(index,1),state.callbacks.length||observedNodes.delete(node),observedNodes.size||cancelAnimationFrame(rafId)}}}}(element,(function(rect){dispatch({rect})}));return observer.observe(),function(){observer.unobserve()}}}),[element]),rect}function rectReducer(state,action){var rect=action.rect;return state.height!==rect.height||state.width!==rect.width?rect:state}var defaultEstimateSize=function defaultEstimateSize(){return 50},defaultKeyExtractor=function defaultKeyExtractor(index){return index},defaultMeasureSize=function defaultMeasureSize(el,horizontal){return el[horizontal?"offsetWidth":"offsetHeight"]},defaultRangeExtractor=function defaultRangeExtractor(range){for(var start=Math.max(range.start-range.overscan,0),end=Math.min(range.end+range.overscan,range.size-1),arr=[],i=start;i<=end;i++)arr.push(i);return arr};function useVirtual(_ref){var _measurements,_ref$size=_ref.size,size=void 0===_ref$size?0:_ref$size,_ref$estimateSize=_ref.estimateSize,estimateSize=void 0===_ref$estimateSize?defaultEstimateSize:_ref$estimateSize,_ref$overscan=_ref.overscan,overscan=void 0===_ref$overscan?1:_ref$overscan,_ref$paddingStart=_ref.paddingStart,paddingStart=void 0===_ref$paddingStart?0:_ref$paddingStart,_ref$paddingEnd=_ref.paddingEnd,paddingEnd=void 0===_ref$paddingEnd?0:_ref$paddingEnd,parentRef=_ref.parentRef,horizontal=_ref.horizontal,scrollToFn=_ref.scrollToFn,useObserver=_ref.useObserver,initialRect=_ref.initialRect,onScrollElement=_ref.onScrollElement,scrollOffsetFn=_ref.scrollOffsetFn,_ref$keyExtractor=_ref.keyExtractor,keyExtractor=void 0===_ref$keyExtractor?defaultKeyExtractor:_ref$keyExtractor,_ref$measureSize=_ref.measureSize,measureSize=void 0===_ref$measureSize?defaultMeasureSize:_ref$measureSize,_ref$rangeExtractor=_ref.rangeExtractor,rangeExtractor=void 0===_ref$rangeExtractor?defaultRangeExtractor:_ref$rangeExtractor,sizeKey=horizontal?"width":"height",scrollKey=horizontal?"scrollLeft":"scrollTop",latestRef=react__WEBPACK_IMPORTED_MODULE_0__.useRef({scrollOffset:0,measurements:[]}),_React$useState=react__WEBPACK_IMPORTED_MODULE_0__.useState(0),scrollOffset=_React$useState[0],setScrollOffset=_React$useState[1];latestRef.current.scrollOffset=scrollOffset;var outerSize=(useObserver||useRect)(parentRef,initialRect)[sizeKey];latestRef.current.outerSize=outerSize;var defaultScrollToFn=react__WEBPACK_IMPORTED_MODULE_0__.useCallback((function(offset){parentRef.current&&(parentRef.current[scrollKey]=offset)}),[parentRef,scrollKey]),resolvedScrollToFn=scrollToFn||defaultScrollToFn;scrollToFn=react__WEBPACK_IMPORTED_MODULE_0__.useCallback((function(offset){resolvedScrollToFn(offset,defaultScrollToFn)}),[defaultScrollToFn,resolvedScrollToFn]);var _React$useState2=react__WEBPACK_IMPORTED_MODULE_0__.useState({}),measuredCache=_React$useState2[0],setMeasuredCache=_React$useState2[1],measure=react__WEBPACK_IMPORTED_MODULE_0__.useCallback((function(){return setMeasuredCache({})}),[]),pendingMeasuredCacheIndexesRef=react__WEBPACK_IMPORTED_MODULE_0__.useRef([]),measurements=react__WEBPACK_IMPORTED_MODULE_0__.useMemo((function(){var min=pendingMeasuredCacheIndexesRef.current.length>0?Math.min.apply(Math,pendingMeasuredCacheIndexesRef.current):0;pendingMeasuredCacheIndexesRef.current=[];for(var measurements=latestRef.current.measurements.slice(0,min),i=min;i<size;i++){var key=keyExtractor(i),measuredSize=measuredCache[key],_start=measurements[i-1]?measurements[i-1].end:paddingStart,_size="number"==typeof measuredSize?measuredSize:estimateSize(i),_end=_start+_size;measurements[i]={index:i,start:_start,size:_size,end:_end,key}}return measurements}),[estimateSize,measuredCache,paddingStart,size,keyExtractor]),totalSize=((null==(_measurements=measurements[size-1])?void 0:_measurements.end)||paddingStart)+paddingEnd;latestRef.current.measurements=measurements,latestRef.current.totalSize=totalSize;var element=onScrollElement?onScrollElement.current:parentRef.current,scrollOffsetFnRef=react__WEBPACK_IMPORTED_MODULE_0__.useRef(scrollOffsetFn);scrollOffsetFnRef.current=scrollOffsetFn,useIsomorphicLayoutEffect((function(){if(element){var onScroll=function onScroll(event){var offset=scrollOffsetFnRef.current?scrollOffsetFnRef.current(event):element[scrollKey];setScrollOffset(offset)};return onScroll(),element.addEventListener("scroll",onScroll,{capture:!1,passive:!0}),function(){element.removeEventListener("scroll",onScroll)}}setScrollOffset(0)}),[element,scrollKey]);var _calculateRange=function calculateRange(_ref4){var measurements=_ref4.measurements,outerSize=_ref4.outerSize,scrollOffset=_ref4.scrollOffset,size=measurements.length-1,getOffset=function getOffset(index){return measurements[index].start},start=findNearestBinarySearch(0,size,getOffset,scrollOffset),end=start;for(;end<size&&measurements[end].end<scrollOffset+outerSize;)end++;return{start,end}}(latestRef.current),start=_calculateRange.start,end=_calculateRange.end,indexes=react__WEBPACK_IMPORTED_MODULE_0__.useMemo((function(){return rangeExtractor({start,end,overscan,size:measurements.length})}),[start,end,overscan,measurements.length,rangeExtractor]),measureSizeRef=react__WEBPACK_IMPORTED_MODULE_0__.useRef(measureSize);measureSizeRef.current=measureSize;var virtualItems=react__WEBPACK_IMPORTED_MODULE_0__.useMemo((function(){for(var virtualItems=[],_loop=function _loop(k,len){var i=indexes[k],item=_extends(_extends({},measurements[i]),{},{measureRef:function measureRef(el){if(el){var measuredSize=measureSizeRef.current(el,horizontal);if(measuredSize!==item.size){var _scrollOffset=latestRef.current.scrollOffset;item.start<_scrollOffset&&defaultScrollToFn(_scrollOffset+(measuredSize-item.size)),pendingMeasuredCacheIndexesRef.current.push(i),setMeasuredCache((function(old){var _extends2;return _extends(_extends({},old),{},((_extends2={})[item.key]=measuredSize,_extends2))}))}}}});virtualItems.push(item)},k=0,len=indexes.length;k<len;k++)_loop(k);return virtualItems}),[indexes,defaultScrollToFn,horizontal,measurements]),mountedRef=react__WEBPACK_IMPORTED_MODULE_0__.useRef(!1);useIsomorphicLayoutEffect((function(){mountedRef.current&&setMeasuredCache({}),mountedRef.current=!0}),[estimateSize]);var scrollToOffset=react__WEBPACK_IMPORTED_MODULE_0__.useCallback((function(toOffset,_temp){var _ref2$align=(void 0===_temp?{}:_temp).align,align=void 0===_ref2$align?"start":_ref2$align,_latestRef$current=latestRef.current,scrollOffset=_latestRef$current.scrollOffset,outerSize=_latestRef$current.outerSize;"auto"===align&&(align=toOffset<=scrollOffset?"start":toOffset>=scrollOffset+outerSize?"end":"start"),"start"===align?scrollToFn(toOffset):"end"===align?scrollToFn(toOffset-outerSize):"center"===align&&scrollToFn(toOffset-outerSize/2)}),[scrollToFn]),tryScrollToIndex=react__WEBPACK_IMPORTED_MODULE_0__.useCallback((function(index,_temp2){var _ref3=void 0===_temp2?{}:_temp2,_ref3$align=_ref3.align,align=void 0===_ref3$align?"auto":_ref3$align,rest=function _objectWithoutPropertiesLoose(source,excluded){if(null==source)return{};var key,i,target={},sourceKeys=Object.keys(source);for(i=0;i<sourceKeys.length;i++)key=sourceKeys[i],excluded.indexOf(key)>=0||(target[key]=source[key]);return target}(_ref3,["align"]),_latestRef$current2=latestRef.current,measurements=_latestRef$current2.measurements,scrollOffset=_latestRef$current2.scrollOffset,outerSize=_latestRef$current2.outerSize,measurement=measurements[Math.max(0,Math.min(index,size-1))];if(measurement){if("auto"===align)if(measurement.end>=scrollOffset+outerSize)align="end";else{if(!(measurement.start<=scrollOffset))return;align="start"}var toOffset="center"===align?measurement.start+measurement.size/2:"end"===align?measurement.end:measurement.start;scrollToOffset(toOffset,_extends({align},rest))}}),[scrollToOffset,size]),scrollToIndex=react__WEBPACK_IMPORTED_MODULE_0__.useCallback((function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];tryScrollToIndex.apply(void 0,args),requestAnimationFrame((function(){tryScrollToIndex.apply(void 0,args)}))}),[tryScrollToIndex]);return{virtualItems,totalSize,scrollToOffset,scrollToIndex,measure}}var findNearestBinarySearch=function findNearestBinarySearch(low,high,getCurrentValue,value){for(;low<=high;){var middle=(low+high)/2|0,currentValue=getCurrentValue(middle);if(currentValue<value)low=middle+1;else{if(!(currentValue>value))return middle;high=middle-1}}return low>0?low-1:0}}}]);